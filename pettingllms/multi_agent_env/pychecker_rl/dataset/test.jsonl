{"input": "\nConsider the function f shown in the Karnaugh map below. Implement this\nfunction.\n\n      x[1]x[2]x[3]x[4]\n      00  01  11  10\n  00 | 1 | 0 | 0 | 1 |\n  01 | 0 | 0 | 0 | 0 |\n  11 | 1 | 1 | 1 | 0 |\n  10 | 1 | 1 | 0 | 1 |\n\nmodule TopModule (\n  input [4:1] x,\n  output logic f\n);\n\n", "spec": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "output": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1;\n\t\t\t4'h1: f = 1;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 0;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 0;\n\t\t\t4'hb: f = 0;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 0;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"input": "\nConsider the state machine shown below:\n\n  A (0) --1--> B\n  A (0) --0--> A\n  B (0) --1--> C\n  B (0) --0--> D\n  C (0) --1--> E\n  C (0) --0--> D\n  D (0) --1--> F\n  D (0) --0--> A\n  E (1) --1--> E\n  E (1) --0--> D\n  F (1) --1--> C\n  F (1) --0--> D\n\nAssume that a one-hot code is used with the state assignment y[5:0] =\n000001(A), 000010(B), 000100(C), 001000(D), 010000(E), 100000(F)\n\nWrite a Verilog for the signal Y1, which is the input of state flip-flop\ny[1], for the signal Y3, which is the input of state flip-flop y[3].\nDerive the Verilog by inspection assuming a one-hot encoding.\n\nmodule TopModule (\n  input [5:0] y,\n  input w,\n  output Y1,\n  output Y3\n);\n\n", "spec": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n", "output": "module top_module (\n\tinput [5:0] y,\n\tinput w,\n\toutput Y1,\n\toutput Y3\n);\n\tassign Y1 = y[0]&w;\n\tassign Y3 = (y[1]|y[2]|y[4]|y[5]) & ~w;\n\nendmodule\n"}
{"input": "\nConsider the state machine shown below:\n\n  A (0) --1--> B\n  A (0) --0--> A\n  B (0) --1--> C\n  B (0) --0--> D\n  C (0) --1--> E\n  C (0) --0--> D\n  D (0) --1--> F\n  D (0) --0--> A\n  E (1) --1--> E\n  E (1) --0--> D\n  F (1) --1--> C\n  F (1) --0--> D\n\nReset resets into state A and is synchronous active-high.\n\nWrite complete Verilog code that represents this FSM. Use separate\n**always** blocks for the state table and the state flip-flops. Describe\nthe FSM output, which is called _z_, using either continuous assignment\nstatement(s) or an **always** block (at your discretion). Assign any\nstate codes that you wish to use.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\tparameter A=0,B=1,C=2,D=3,E=4,F=5;\n\treg[2:0] state, next;\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\t\t\n\t\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = w ? B : A;\n\t\t\tB: next = w ? C : D;\n\t\t\tC: next = w ? E : D;\n\t\t\tD: next = w ? F : A;\n\t\t\tE: next = w ? E : D;\n\t\t\tF: next = w ? C : D;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t\n\tassign z = (state == E) || (state == F);\n\nendmodule\n"}
{"input": "\nConsider the FSM described by the state diagram shown below:\n\n  A --r1=0,r2=0,r3=0--> A\n  A --r1=1--> B\n  A --r1=0,r2=1--> C\n  A --r1=0,r2=0,r3=0--> D\n  B (g1=1) --r1=1--> B\n  B (g1=1) --r1=0--> A\n  C (g2=1) --r2=1--> C\n  C (g2=1) --r2=0--> A\n\nResetn is an active-low synchronous reset that resets into state A. This\nFSM acts as an arbiter circuit, which controls access to some type of\nresource by three requesting devices. Each device makes its request for\nthe resource by setting a signal _r[i]_ = 1, where _r[i]_ is either\n_r[1]_, _r[2]_, or _r[3]_. Each r[i] is an input signal to the FSM, and\nrepresents one of the three devices. The FSM stays in state _A_ as long\nas there are no requests. When one or more request occurs, then the FSM\ndecides which device receives a grant to use the resource and changes to\na state that sets that device's _g[i]_ signal to 1. Each _g[i]_ is an\noutput from the FSM. There is a priority system, in that device 1 has a\nhigher priority than device 2, and device 3 has the lowest priority.\nHence, for example, device 3 will only receive a grant if it is the only\ndevice making a request when the FSM is in state _A_. Once a device, _i_,\nis given a grant by the FSM, that device continues to receive the grant\nas long as its request, _r[i]_ = 1.\n\nWrite complete Verilog code that represents this FSM. Use separate always\nblocks for the state table and the state flip-flops, as done in lectures.\nDescribe the FSM outputs, _g[i]_, using either continuous assignment\nstatement(s) or an always block (at your discretion). Assign any state\ncodes that you wish to use.\n\nmodule TopModule (\n  input clk,\n  input resetn,\n  input [3:1] r,\n  output [3:1] g\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways@(state,r) begin\n\t\tcase (state)\n\t\t\tA: if (r[1]) next = B;\n\t\t\t   else if (r[2]) next = C;\n\t\t\t   else if (r[3]) next = D;\n\t\t\t   else next = A;\n\t\t\tB: next = r[1] ? B : A;\n\t\t\tC: next = r[2] ? C : A;\n\t\t\tD: next = r[3] ? D : A;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign g[1] = (state == B);\t\n\tassign g[2] = (state == C);\t\n\tassign g[3] = (state == D);\t\nendmodule\n"}
{"input": "\nConsider a finite state machine that is used to control some type of\nmotor. The FSM has inputs x and y, which come from the motor, and\nproduces outputs f and g, which control the motor. There is also a clock\ninput called clk and a reset input (synchronous, active low) called\nresetn. The FSM has to work as follows. As long as the reset input is\nasserted, the FSM stays in a beginning state, called state A. When the\nreset signal is de-asserted, then after the next clock edge the FSM has\nto set the output f to 1 for one clock cycle. Then, the FSM has to\nmonitor the x input. When x has produced the values 1, 0, 1 in three\nsuccessive clock cycles, then g should be set to 1 on the following clock\ncycle. While maintaining g = 1 the FSM has to monitor the y input. If y\nhas the value 1 within at most two clock cycles, then the FSM should\nmaintain g = 1 permanently (that is, until reset). But if y does not\nbecome 1 within two clock cycles, then the FSM should set g = 0\npermanently (until reset).\n\nmodule TopModule (\n  input clk,\n  input resetn,\n  input x,\n  input y,\n  output f,\n  output g\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput x,\n\tinput y,\n\toutput f,\n\toutput g\n);\n\tparameter A=0, B=1, S0=2, S1=3, S10=4, G1=5, G2=6, P0=7, P1=8;\n\treg [3:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = B;\n\t\t\tB: next = S0;\n\t\t\tS0: next = x ? S1 : S0;\n\t\t\tS1: next = x ? S1 : S10;\n\t\t\tS10: next = x? G1 : S0;\n\t\t\tG1: next = y ? P1 : G2;\n\t\t\tG2: next = y ? P1 : P0;\n\t\t\tP0: next = P0;\n\t\t\tP1: next = P1;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign f = (state == B);\n\tassign g = (state == G1) || (state == G2) || (state == P1);\nendmodule\n"}
{"input": "\nGiven the state-assigned table shown below, implement the finite-state\nmachine. Reset should synchronous active high reset the FSM to state 000.\n\n  Present state y[2:0] | Next state y[2:0] x=0, Next state y[2:0] x=1 | Output z\n  000 | 000, 001 | 0\n  001 | 001, 100 | 0\n  010 | 010, 001 | 0\n  011 | 001, 010 | 1\n  100 | 011, 100 | 1\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input x,\n  output reg z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput x,\n\toutput reg z\n);\n\tparameter A=0, B=1, C=2, D=3, E=4;\n\treg [2:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = x ? B : A;\n\t\t\tB: next = x ? E : B;\n\t\t\tC: next = x ? B : C;\n\t\t\tD: next = x ? C : B;\n\t\t\tE: next = x ? E : D;\t\t\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign z = (state == D) || (state == E);\n\t\nendmodule\n"}
{"input": "\nGiven the state-assigned table shown below, implement the logic functions\nY[0] and z.\n\n   Present state input y[2:0] | Next state Y[2:0] when x=0, Next state Y[2:0] when x=1 | Output z\n   000 | 000, 001 | 0\n   001 | 001, 100 | 0\n   010 | 010, 001 | 0\n   011 | 001, 010 | 1\n   100 | 011, 100 | 1\n\nmodule TopModule (\n  input clk,\n  input x,\n  input [2:0] y,\n  output reg Y0,\n  output reg z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput x,\n\tinput [2:0] y,\n\toutput reg Y0,\n\toutput reg z\n);\n\n\talways @(*) begin\n\t\tcase ({y[2:0], x})\n\t\t\t4'h0: Y0 = 0;\n\t\t\t4'h1: Y0 = 1;\n\t\t\t4'h2: Y0 = 1;\n\t\t\t4'h3: Y0 = 0;\n\t\t\t4'h4: Y0 = 0;\n\t\t\t4'h5: Y0 = 1;\n\t\t\t4'h6: Y0 = 1;\n\t\t\t4'h7: Y0 = 0;\n\t\t\t4'h8: Y0 = 1;\n\t\t\t4'h9: Y0 = 0;\n\t\t\tdefault: Y0 = 1'bx;\n\t\tendcase\n\t\t\n\t\tcase (y[2:0])\n\t\t\t3'h0: z = 0;\n\t\t\t3'h1: z = 0;\n\t\t\t3'h2: z = 0;\n\t\t\t3'h3: z = 1;\n\t\t\t3'h4: z = 1;\n\t\t\tdefault: z = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nConsider a finite state machine with inputs s and w. Assume that the FSM\nbegins in a reset state called A, as depicted below. The FSM remains in\nstate A as long as s = 0, and it moves to state B when s = 1. Once in\nstate B the FSM examines the value of the input w in the next three clock\ncycles. If w = 1 in exactly two of these clock cycles, then the FSM has\nto set an output z to 1 in the following clock cycle. Otherwise z has to\nbe 0. The FSM continues checking w for the next three clock cycles, and\nso on. Use as few states as possible. Note that the s input is used only\nin state A, so you need to consider just the w input. Assume reset is\nactive high synchronous.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input s,\n  input w,\n  output reg z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput s,\n\tinput w,\n\toutput reg z\n);\n\tparameter A=0, B=1, C=2, S10=3, S11=4, S20=5, S21=6, S22=7;\n\treg [2:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (reset) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA: next = s ? B : A;\n\t\t\tB: next = w ? S11 : S10;\n\t\t\tC: next = w ? S11 : S10;\n\t\t\tS10: next = w ? S21 : S20;\n\t\t\tS11: next = w ? S22 : S21;\n\t\t\tS20: next = B;\n\t\t\tS21: next = w ? C : B;\n\t\t\tS22: next = w ? B : C;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign z = (state == C);\n\t\nendmodule\n"}
{"input": "\nConsider an n-bit shift register circuit. Inputs E are for enabling\nshift, R for value to load, L is asserted when it should load, and w is\nthe input to the first stage of the shift register. Write a Verilog\nmodule named top_module for one stage of this circuit, including both the\nflip-flop and multiplexers.\n\nmodule TopModule (\n  input clk,\n  input w,\n  input R,\n  input E,\n  input L,\n  output reg Q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput w,\n\tinput R,\n\tinput E,\n\tinput L,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tif (L)\n\t\t\tQ <= R;\n\t\telse if (E)\n\t\t\tQ <= w;\n\t\nendmodule\n"}
{"input": "\nThe 7400-series integrated circuits are a series of digital chips with a\nfew gates each. The 7420 is a chip with two 4-input NAND gates.\n\nCreate a module with the same functionality as the 7420 chip. It has 8\ninputs and 2 outputs.\n\nmodule TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n", "spec": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "output": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d, \n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = ~&( {p1a, p1b, p1c, p1d} );\n\tassign p2y = ~&( {p2a, p2b, p2c, p2d} );\n\t\nendmodule\n"}
{"input": "\nThe 7458 is a chip with four AND gates and two OR gates. Create a module\nin Verilog with the same functionality as the 7458 chip. It has 10 inputs\nand 2 outputs. You may choose to use an `assign` statement to drive each\nof the output wires, or you may choose to declare (four) wires for use as\nintermediate signals, where each internal wire is driven by the output of\none of the AND gates.\n\nIn this circuit, p1y should be the OR of two 3-input AND gates: one that\nANDs p1a, p1b, and p1c, and the second that ANDs p1d, p1e, and p1f. The\noutput p2y is the OR of two 2-input AND gates: one that ANDs p2a and p2b,\nand the second that ANDs p2c and p2d.\n\nmodule TopModule (\n  input p1a,\n  input p1b,\n  input p1c,\n  input p1d,\n  input p1e,\n  input p1f,\n  output p1y,\n  input p2a,\n  input p2b,\n  input p2c,\n  input p2d,\n  output p2y\n);\n\n", "spec": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n", "output": "module top_module(\n\tinput p1a, \n\tinput p1b, \n\tinput p1c, \n\tinput p1d,\n\tinput p1e,\n\tinput p1f,\n\toutput p1y, \n\tinput p2a, \n\tinput p2b, \n\tinput p2c, \n\tinput p2d, \n\toutput p2y\n);\n\t\n\tassign p1y = &{p1a, p1b, p1c} | &{p1d, p1e, p1f};\n\tassign p2y = &{p2a, p2b} | &{p2c, p2d};\n\t\nendmodule\n"}
{"input": "\nCreate a 6-to-1 multiplexer. When sel is between 0 and 5, choose the\ncorresponding data input. Otherwise, output 0. The data inputs and\noutputs are all 4 bits wide.\n\nmodule TopModule (\n  input [2:0] sel,\n  input [3:0] data0,\n  input [3:0] data1,\n  input [3:0] data2,\n  input [3:0] data3,\n  input [3:0] data4,\n  input [3:0] data5,\n  output reg [3:0] out\n);\n\n", "spec": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n", "output": "module top_module (\n\tinput [2:0] sel,\n\tinput [3:0] data0,\n\tinput [3:0] data1,\n\tinput [3:0] data2,\n\tinput [3:0] data3,\n\tinput [3:0] data4,\n\tinput [3:0] data5,\n\toutput reg [3:0] out\n);\n\n\talways @(*) begin\n\t\tcase (sel)\n\t\t\t3'h0: out = data0;\n\t\t\t3'h1: out = data1;\n\t\t\t3'h2: out = data2;\n\t\t\t3'h3: out = data3;\n\t\t\t3'h4: out = data4;\n\t\t\t3'h5: out = data5;\n\t\t\tdefault: out = 4'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nA priority encoder is a combinational circuit that, when given an input\nbit vector, outputs the position of the first 1 bit in the vector. For\nexample, a 8-bit priority encoder given the input 8'b10010000 would\noutput 3'd4, because bit[4] is first bit that is high. Build a 4-bit\npriority encoder. For this problem, if none of the input bits are high\n(i.e., input is zero), output zero. Note that a 4-bit number has 16\npossible combinations.\n\nmodule TopModule (\n  input [3:0] in,\n  output reg [1:0] pos\n);\n\n", "spec": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n", "output": "module top_module (\n\tinput [3:0] in,\n\toutput reg [1:0] pos\n);\n\n\talways @(*) begin\n\t\tcase (in)\n\t\t\t4'h0: pos = 2'h0;\n\t\t\t4'h1: pos = 2'h0;\n\t\t\t4'h2: pos = 2'h1;\n\t\t\t4'h3: pos = 2'h0;\n\t\t\t4'h4: pos = 2'h2;\n\t\t\t4'h5: pos = 2'h0;\n\t\t\t4'h6: pos = 2'h1;\n\t\t\t4'h7: pos = 2'h0;\n\t\t\t4'h8: pos = 2'h3;\n\t\t\t4'h9: pos = 2'h0;\n\t\t\t4'ha: pos = 2'h1;\n\t\t\t4'hb: pos = 2'h0;\n\t\t\t4'hc: pos = 2'h2;\n\t\t\t4'hd: pos = 2'h0;\n\t\t\t4'he: pos = 2'h1;\n\t\t\t4'hf: pos = 2'h0;\n\t\t\tdefault: pos = 2'b0;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nBuild a priority encoder for 8-bit inputs. Given an 8-bit vector, the\noutput should report the first (least significant) bit in the vector that\nis 1. Report zero if the input vector has no bits that are high. For\nexample, the input 8'b10010000 should output 3'd4, because bit[4] is\nfirst bit that is high.\n\nmodule TopModule (\n  input [7:0] in,\n  output reg [2:0] pos\n);\n\n", "spec": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n", "output": "module top_module (\n\tinput [7:0] in,\n\toutput reg [2:0] pos\n);\n\n\talways @(*) begin\n\t\tcasez (in)\n\t\t\tdefault : pos = 2'h0;\n\t\t\t8'bzzzzzzz1: pos = 3'h0;\n\t\t\t8'bzzzzzz1z: pos = 3'h1;\n\t\t\t8'bzzzzz1zz: pos = 3'h2;\n\t\t\t8'bzzzz1zzz: pos = 3'h3;\n\t\t\t8'bzzz1zzzz: pos = 3'h4;\n\t\t\t8'bzz1zzzzz: pos = 3'h5;\n\t\t\t8'bz1zzzzzz: pos = 3'h6;\n\t\t\t8'b1zzzzzzz: pos = 3'h7;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nBuild a 2-to-1 mux that chooses between a and b. Choose b if both sel_b1\nand sel_b2 are true. Otherwise, choose a. Do the same twice, once using\nassign statements and once using a procedural if statement.\n\nmodule TopModule (\n  input a,\n  input b,\n  input sel_b1,\n  input sel_b2,\n  output out_assign,\n  output reg out_always\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel_b1,\n\tinput sel_b2,\n\toutput out_assign,\n\toutput reg out_always\n);\n\n\tassign out_assign = (sel_b1 & sel_b2) ? b : a;\n\talways @(*) out_always = (sel_b1 & sel_b2) ? b : a;\n\t\nendmodule\n"}
{"input": "\nFix any and all bugs in this code:\n\n  module top_module (\n      input      cpu_overheated,\n      output reg shut_off_computer,\n      input      arrived,\n      input      gas_tank_empty,\n      output reg keep_driving  );\n\n      always @(*) begin\n          if (cpu_overheated)\n             shut_off_computer = 1;\n      end\n\n      always @(*) begin\n          if (~arrived)\n             keep_driving = ~gas_tank_empty;\n      end\n\n  endmodule\n\nmodule TopModule (\n  input cpu_overheated,\n  output reg shut_off_computer,\n  input arrived,\n  input gas_tank_empty,\n  output reg keep_driving\n);\n\n", "spec": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n", "output": "module top_module (\n\tinput cpu_overheated,\n\toutput reg shut_off_computer,\n\tinput arrived,\n\tinput gas_tank_empty,\n\toutput reg keep_driving\n);\n\n\talways @(*) begin\n\t\tif (cpu_overheated)\n\t\t\tshut_off_computer = 1;\n\t\telse\n\t\t\tshut_off_computer = 0;\n\tend\n\t\n\talways @(*) begin\n\t\tif (~arrived)\n\t\t\tkeep_driving = !gas_tank_empty;\n\t\telse\n\t\t\tkeep_driving = 1'b0;\n\tend\n\t\nendmodule\n"}
{"input": "\nSuppose you're building a circuit to process scancodes from a PS/2\nkeyboard for a game. Given the last two bytes of scancodes received, you\nneed to indicate whether one of the arrow keys on the keyboard have been\npressed. This involves a fairly simple mapping, which can be implemented\nas a case statement (or if-elseif) with four cases.\n\n  Scancode[15:0] | Arrow key\n  16'he06b       | left arrow\n  16'he072       | down arrow\n  16'he074       | right arrow\n  16'he075       | up arrow\n  Anything else  | none\n\nYour circuit has one 16-bit input, and four outputs. Build this circuit\nthat recognizes these four scancodes and asserts the correct output.\n\nmodule TopModule (\n  input [15:0] scancode,\n  output reg left,\n  output reg down,\n  output reg right,\n  output reg up\n);\n\n", "spec": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n", "output": "module top_module (\n\tinput [15:0] scancode,\n\toutput reg left,\n\toutput reg down,\n\toutput reg right,\n\toutput reg up\n);\n\n\talways @(*) begin\n\t\t{up, left, down, right} = 0;\n\t\tcase (scancode)\n\t\t\t16'he06b: left = 1;\n\t\t\t16'he072: down = 1;\n\t\t\t16'he074: right = 1;\n\t\t\t16'he075: up = 1;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nBuild an AND gate using both an assign statement and a combinational\nalways block.\n\nmodule TopModule (\n  input a,\n  input b,\n  output out_assign,\n  output reg out_alwaysblock\n);\n\n", "spec": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n", "output": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_alwaysblock\n);\n\t\n\tassign out_assign = a & b;\n\talways @(*) out_alwaysblock = a & b;\n\t\nendmodule\n"}
{"input": "\nBuild an XOR gate three ways, using an assign statement (output\nout_assign), a combinational always block (output out_always_comb), and a\nclocked always block (output out_always_ff). Note that the clocked always\nblock produces a different circuit from the other two: There is a flip-\nflop so the output is delayed.\n\nmodule TopModule (\n  input clk,\n  input a,\n  input b,\n  output out_assign,\n  output reg out_always_comb,\n  output reg out_always_ff\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n", "output": "module top_module(\n\tinput clk,\n\tinput a, \n\tinput b,\n\toutput out_assign,\n\toutput reg out_always_comb,\n\toutput reg out_always_ff\n);\n\t\n\tassign out_assign = a ^ b;\n\talways @(*) out_always_comb = a ^ b;\n\talways @(posedge clk) out_always_ff <= a ^ b;\n\t\nendmodule\n"}
{"input": "\nCreate a module that implements an AND gate.\n\nmodule TopModule (\n  input a,\n  input b,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "output": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = a & b;\n\t\nendmodule\n"}
{"input": "\nThe following adder-subtractor with zero flag doesn't work. Fix the\nbug(s).\n\n  synthesis verilog_input_version verilog_2001\n  module top_module (\n      input do_sub,\n      input [7:0] a,\n      input [7:0] b,\n      output reg [7:0] out,\n      output reg result_is_zero\n  );\n\n      always @(*) begin\n          case (do_sub)\n            0: out = a+b;\n            1: out = a-b;\n          endcase\n\n          if (~out)\n              result_is_zero = 1;\n      end\n\n  endmodule\n\nmodule TopModule (\n  input do_sub,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out,\n  output reg result_is_zero\n);\n\n", "spec": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n", "output": "module top_module (\n\tinput do_sub,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out,\n\toutput reg result_is_zero\n);\n\n\talways @(*) begin\n\t\tcase (do_sub)\n\t\t\t0: out = a + b;\n\t\t\t1: out = a - b;\n\t\tendcase\n\t\tresult_is_zero = (out == 0);\n\tend\n\t\nendmodule\n"}
{"input": "\nThis combinational circuit is supposed to recognize 8-bit keyboard\nscancodes for keys 0 through 9. It should indicate whether one of the 10\ncases were recognized (valid), and if so, which key was detected. If the\n8-bit input is 8'h45, 8'h16, 8'h1e, 8'h26, 8'h25, 8'h2e, 8'h36, 8'h3d,\n8'h3e, or 8'h46, the 4-bit output will be set to 0, 1, 2, 3, 4, 5, 6, 7,\n8, or 9 respectively, the 1-bit valid would be set to 1. If the input\ndoes not match any of the cases, both output signals would be set to 0.\n\nmodule TopModule (\n  input [7:0] code,\n  output reg [3:0] out,\n  output reg valid\n);\n\n", "spec": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n", "output": "module top_module (\n\tinput [7:0] code,\n\toutput reg [3:0] out,\n\toutput reg valid\n);\n//\tuhh.. make a case statement: maps scancode to 0-9, but accidentally infer a latch?\n//  and have one of the entries be wrong? (duplicate case, using different base!) \n\talways @(*) begin\n\t\tout = 0;\n\t\tvalid = 1;\n\t\tcase (code)\n\t\t\t8'h45: out = 0;\n\t\t\t8'h16: out = 1;\n\t\t\t8'h1e: out = 2;\n\t\t\t8'h26: out = 3;\n\t\t\t8'h25: out = 4;\n\t\t\t8'h2e: out = 5;\n\t\t\t8'h36: out = 6;\n\t\t\t8'h3d: out = 7;\n\t\t\t8'h3e: out = 8;\n\t\t\t8'h46: out = 9;\n\t\t\tdefault: valid = 0;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nFind the bug and fix this 8-bit wide 2-to-1 mux.\n\n  module top_module (\n      input sel,\n      input [7:0] a,\n      input [7:0] b,\n      output out  );\n\n      assign out = (~sel & a) | (sel & b);\n\n  endmodule\n\nmodule TopModule (\n  input sel,\n  input [7:0] a,\n  input [7:0] b,\n  output reg [7:0] out\n);\n\n", "spec": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "output": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n\t// assign out = (~sel & a) | (sel & b);\n    assign out = sel ? a : b;\n\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time            a               b               q\n  0ns             0               0               0\n  5ns             0               0               0\n  10ns            0               0               0\n  15ns            0               0               0\n  20ns            0               0               0\n  25ns            0               1               0\n  30ns            0               1               0\n  35ns            1               0               0\n  40ns            1               0               0\n  45ns            1               1               1\n  50ns            1               1               1\n  55ns            0               0               0\n  60ns            0               0               0\n  65ns            0               1               0\n  70ns            0               1               0\n  75ns            1               0               0\n  80ns            1               0               0\n  85ns            1               1               1\n  90ns            1               1               1\n\nmodule TopModule (\n  input a,\n  input b,\n  output q\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b, \n\toutput q\n);\n\n\tassign q = a&b;\n\t\nendmodule\n"}
{"input": "\nThis is a sequential circuit. The circuit consists of combinational logic\nand one bit of memory (i.e., one flip-flop). The output of the flip-flop\nhas been made observable through the output state.\n\n  Read the simulation waveforms to determine what the circuit does, then implement it.\n\n  time            clk             a               b               state           q\n  0ns             0               1               x               x               x\n  5ns             1               1               x               x               x\n  10ns            0               0               0               x               x\n  15ns            1               0               0               0               0\n  20ns            0               0               0               0               0\n  25ns            1               0               0               0               0\n  30ns            0               0               0               0               0\n  35ns            1               0               0               0               0\n  40ns            0               0               0               0               0\n  45ns            1               0               1               0               1\n  50ns            0               0               1               0               1\n  55ns            1               1               0               0               1\n  60ns            0               1               0               0               1\n  65ns            1               1               1               0               0\n  70ns            0               1               1               0               0\n  75ns            1               0               0               1               1\n  80ns            0               0               0               1               1\n  85ns            1               1               1               0               0\n  90ns            0               1               1               0               0\n  95ns            1               1               1               1               1\n  100ns           0               1               1               1               1\n  105ns           1               1               1               1               1\n  110ns           0               1               1               1               1\n  115ns           1               1               0               1               0\n  120ns           0               1               0               1               0\n  125ns           1               0               1               1               0\n  130ns           0               0               1               1               0\n  135ns           1               0               0               1               1\n  140ns           0               0               0               1               1\n  145ns           1               0               0               0               0\n  150ns           0               0               0               0               0\n  155ns           1               0               0               0               0\n  160ns           0               0               0               0               0\n  165ns           1               0               0               0               0\n  170ns           0               0               0               0               0\n  175ns           1               0               0               0               0\n  180ns           0               0               0               0               0\n  185ns           1               0               0               0               0\n  190ns           0               0               0               0               0\n\nmodule TopModule (\n  input clk,\n  input a,\n  input b,\n  output q,\n  output state\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput a,\n\tinput b,\n\toutput q,\n\toutput state\n);\n\n\treg c;\n\talways @(posedge clk)\n\t\tc <= a&b | a&c | b&c;\n\t\n\tassign q = a^b^c;\n\tassign state = c;\n\t\t\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  1\n  5ns   0  0  0  0  1\n  10ns  0  0  0  0  1\n  15ns  0  0  0  0  1\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  0\n  30ns  0  0  1  1  1\n  35ns  0  1  0  0  0\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  0\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  1\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  0\n  75ns  1  1  0  0  1\n  80ns  1  1  0  1  0\n  85ns  1  1  1  0  0\n  90ns  1  1  1  1  1\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = ~a^b^c^d;\n\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  0\n  5ns   0  0  0  0  0\n  10ns  0  0  0  0  0\n  15ns  0  0  0  0  0\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  0\n  30ns  0  0  1  1  0\n  35ns  0  1  0  0  0\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  1\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  1\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  1\n  75ns  1  1  0  0  0\n  80ns  1  1  0  1  1\n  85ns  1  1  1  0  1\n  90ns  1  1  1  1  1\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = (a|b) & (c|d);\n\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time  a  b  c  d  q\n  0ns   0  0  0  0  0\n  5ns   0  0  0  0  0\n  10ns  0  0  0  0  0\n  15ns  0  0  0  0  0\n  20ns  0  0  0  1  0\n  25ns  0  0  1  0  1\n  30ns  0  0  1  1  1\n  35ns  0  1  0  0  1\n  40ns  0  1  0  1  1\n  45ns  0  1  1  0  1\n  50ns  0  1  1  1  1\n  55ns  1  0  0  0  0\n  60ns  1  0  0  1  0\n  65ns  1  0  1  0  1\n  70ns  1  0  1  1  1\n  75ns  1  1  0  0  1\n  80ns  1  1  0  1  1\n  85ns  1  1  1  0  1\n  90ns  1  1  1  1  1\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output q\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b, \n\tinput c, \n\tinput d,\n\toutput q\n);\n\n\tassign q = c | b;\n\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time  a  b  c  d  e  q\n  0ns   x  x  x  x  x  x\n  5ns   x  x  x  x  x  x\n  10ns  x  x  x  x  x  x\n  15ns  a  b  0  d  e  b\n  20ns  a  b  1  d  e  e\n  25ns  a  b  2  d  e  a\n  30ns  a  b  3  d  e  d\n  35ns  a  b  4  d  e  f\n  40ns  a  b  5  d  e  f\n  45ns  a  b  6  d  e  f\n  50ns  a  b  7  d  e  f\n  55ns  a  b  8  d  e  f\n  60ns  a  b  9  d  e  f\n  65ns  a  b  a  d  e  f\n  70ns  a  b  b  d  e  f\n  75ns  a  b  c  d  e  f\n  80ns  a  b  d  d  e  f\n  85ns  a  b  e  d  e  f\n  90ns  a  b  f  d  e  f\n\nmodule TopModule (\n  input [3:0] a,\n  input [3:0] b,\n  input [3:0] c,\n  input [3:0] d,\n  input [3:0] e,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n", "output": "module top_module (\n\tinput [3:0] a, \n\tinput [3:0] b, \n\tinput [3:0] c, \n\tinput [3:0] d,\n\tinput [3:0] e,\n\toutput reg [3:0] q\n);\n\n\talways @(*) \n\t\tcase (c)\n\t\t\t0: q = b;\n\t\t\t1: q = e;\n\t\t\t2: q = a;\n\t\t\t3: q = d;\n\t\t\tdefault: q = 4'hf;\n\t\tendcase\n\t\nendmodule\n"}
{"input": "\nThis is a combinational circuit. Read the simulation waveforms to\ndetermine what the circuit does, then implement it.\n\n  time  a     q\n  0ns   x     x\n  5ns   x     x\n  10ns  x     x\n  15ns  0  1232\n  20ns  1  aee0\n  25ns  2  27d4\n  30ns  3  5a0e\n  35ns  4  2066\n  40ns  5  64ce\n  45ns  6  c526\n  50ns  7  2f19\n  55ns  0  1232\n  60ns  1  aee0\n  65ns  2  27d4\n  70ns  4  2066\n  75ns  1  aee0\n  80ns  1  aee0\n  85ns  3  5a0e\n  90ns  5  64ce\n\nmodule TopModule (\n  input [2:0] a,\n  output reg [15:0] q\n);\n\n", "spec": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n", "output": "module top_module (\n\tinput [2:0] a, \n\toutput reg [15:0] q\n);\n\n\talways @(*) \n\t\tcase (a)\n\t\t\t0: q = 4658;\n\t\t\t1: q = 44768;\n\t\t\t2: q = 10196;\n\t\t\t3: q = 23054;\n\t\t\t4: q = 8294;\n\t\t\t5: q = 25806;\n\t\t\t6: q = 50470;\n\t\t\t7: q = 12057;\n\t\tendcase\n\t\nendmodule\n"}
{"input": "\nThis is a sequential circuit. Read the simulation waveforms to determine\nwhat the circuit does, then implement it.\n\n  time  clk a   q\n  0ns   0   x   x\n  5ns   1   0   x\n  10ns  0   0   x\n  15ns  1   0   1\n  20ns  0   0   1\n  25ns  1   0   1\n  30ns  0   0   1\n  35ns  1   1   1\n  40ns  0   1   1\n  45ns  1   1   0\n  50ns  0   1   0\n  55ns  1   1   0\n  60ns  0   1   0\n  65ns  1   1   0\n  70ns  0   1   0\n  75ns  1   1   0\n  80ns  0   1   0\n  85ns  1   1   0\n  90ns  0   1   0\n\nmodule TopModule (\n  input clk,\n  input a,\n  output reg q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg q\n);\n\n\talways @(posedge clk)\n\t\tq <= ~a;\n\t\t\nendmodule\n"}
{"input": "\nThis is a sequential circuit. Read the simulation waveforms to determine\nwhat the circuit does, then implement it.\n\n  time   clock  a   p   q\n  0ns    0      0   x   x\n  5ns    0      0   x   x\n  10ns   0      0   x   x\n  15ns   0      0   x   x\n  20ns   0      0   x   x\n  25ns   1      0   0   x\n  30ns   1      0   0   x\n  35ns   1      0   0   x\n  40ns   1      0   0   x\n  45ns   1      0   0   x\n  50ns   1      0   0   x\n  55ns   0      0   0   0\n  60ns   0      0   0   0\n  65ns   0      0   0   0\n  70ns   0      1   0   0\n  75ns   0      0   0   0\n  80ns   0      1   0   0\n  85ns   1      0   0   0\n  90ns   1      1   1   0\n  95ns   1      0   0   0\n  100ns  1      1   1   0\n  105ns  1      0   0   0\n  110ns  1      1   1   0\n  115ns  0      0   1   1\n  120ns  0      1   1   1\n  125ns  0      0   1   1\n  130ns  0      1   1   1\n  135ns  0      0   1   1\n  140ns  0      0   1   1\n  145ns  1      0   0   1\n  150ns  1      0   0   1\n  155ns  1      0   0   1\n  160ns  1      0   0   1\n  165ns  1      1   1   1\n  170ns  1      0   0   1\n  175ns  0      1   0   0\n  180ns  0      0   0   0\n  185ns  0      1   0   0\n  190ns  0      0   0   0\n\nmodule TopModule (\n  input clock,\n  input a,\n  output reg p,\n  output reg q\n);\n\n", "spec": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n", "output": "module top_module (\n\tinput clock,\n\tinput a, \n\toutput reg p,\n\toutput reg q\n);\n\n\talways @(negedge clock)\n\t\tq <= a;\n\t\t\n\talways @(*)\n\t\tif (clock)\n\t\t\tp = a;\nendmodule\n"}
{"input": "\nThis is a sequential circuit. Read the simulation waveforms to determine\nwhat the circuit does, then implement it.\n\n  time  clk a   q\n  0ns   0   1   x\n  5ns   1   1   4\n  10ns  0   1   4\n  15ns  1   1   4\n  20ns  0   1   4\n  25ns  1   1   4\n  30ns  0   1   4\n  35ns  1   1   4\n  40ns  0   1   4\n  45ns  1   0   4\n  50ns  0   0   4\n  55ns  1   0   5\n  60ns  0   0   5\n  65ns  1   0   6\n  70ns  0   0   6\n  75ns  1   0   0\n  80ns  0   0   0\n  85ns  1   0   1\n  90ns  0   0   1\n\nmodule TopModule (\n  input clk,\n  input a,\n  output reg [2:0] q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput a, \n\toutput reg [2:0] q\n);\n\n\talways @(posedge clk)\n\t\tif (a)\n\t\t\tq <= 4;\n\t\telse if (q == 6)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q + 1'b1;\n\t\t\t\nendmodule\n"}
{"input": "\nGiven four unsigned numbers, find the minimum. Unsigned numbers can be\ncompared with standard comparison operators (a < b).\n\nmodule TopModule (\n  input [7:0] a,\n  input [7:0] b,\n  input [7:0] c,\n  input [7:0] d,\n  output reg [7:0] min\n);\n\n", "spec": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n", "output": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\tinput [7:0] c,\n\tinput [7:0] d,\n\toutput reg [7:0] min\n);\n\n\talways_comb begin\n\t\tmin = a;\n\t\tif (min > b) min = b;\n\t\tif (min > c) min = c;\n\t\tif (min > d) min = d;\n\tend\n\t\nendmodule\n"}
{"input": "\nThe \"game\" is played on a two-dimensional grid of cells, where each cell\nis either 1 (alive) or 0 (dead). At each time step, each cell changes\nstate depending on how many neighbours it has:\n\n  (1) 0-1 neighbour: Cell becomes 0.\n  (2) 2 neighbours: Cell state does not change.\n  (3) 3 neighbours: Cell becomes 1.\n  (4) 4+ neighbours: Cell becomes 0.\n\nThe game is formulated for an infinite grid. In this circuit, we will use\na 16x16 grid. To make things more interesting, we will use a 16x16\ntoroid, where the sides wrap around to the other side of the grid. For\nexample, the corner cell (0,0) has 8 neighbours: (15,1), (15,0), (15,15),\n(0,1), (0,15), (1,1), (1,0), and (1,15). The 16x16 grid is represented by\na length 256 vector, where each row of 16 cells is represented by a\nsub-vector: q[15:0] is row 0, q[31:16] is row 1, etc.\n\n  (1) load: Loads data into q at the next clock edge, for loading initial\n       state. Active high synchronous.\n  (2) q: The 16x16 current state of the game, updated every clock cycle.\n\nThe game state should advance by one timestep every clock cycle.\n\nmodule TopModule (\n  input clk,\n  input load,\n  input [255:0] data,\n  output reg [255:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [255:0] data,\n\toutput reg [255:0] q);\n\t\n\t\n\tlogic [323:0] q_pad;\n\talways@(*) begin\n\t\tfor (int i=0;i<16;i++)\n\t\t\tq_pad[18*(i+1)+1 +: 16] = q[16*i +: 16];\n\t\tq_pad[1 +: 16] = q[16*15 +: 16];\n\t\tq_pad[18*17+1 +: 16] = q[0 +: 16];\n\t\t\n\t\tfor (int i=0; i<18; i++) begin\n\t\t\tq_pad[i*18] = q_pad[i*18+16];\n\t\t\tq_pad[i*18+17] = q_pad[i*18+1];\n\t\tend\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tfor (int i=0;i<16;i++)\n\t\tfor (int j=0;j<16;j++) begin\n\t\t\tq[i*16+j] <= \n\t\t\t\t((q_pad[(i+1)*18+j+1 -1+18] + q_pad[(i+1)*18+j+1 +18] + q_pad[(i+1)*18+j+1 +1+18] +\n\t\t\t\tq_pad[(i+1)*18+j+1 -1]                                + q_pad[(i+1)*18+j+1+1] +\n\t\t\t\tq_pad[(i+1)*18+j+1 -1-18]   + q_pad[(i+1)*18+j+1 -18] + q_pad[(i+1)*18+j+1 +1-18]) & 3'h7 | q[i*16+j]) == 3'h3;\n\t\tend\n\t\t\n\t\tif (load)\n\t\t\tq <= data;\n\t\t\n\tend\n\t\nendmodule\n"}
{"input": "\nBuild a decade counter that counts from 0 through 9, inclusive, with a\nperiod of 10. The reset input is active high synchronous, and should\nreset the counter to 0.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 9)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n"}
{"input": "\nBuild a 4-bit binary counter that counts from 0 through 15, inclusive,\nwith a period of 16. The reset input is active high synchronous, and\nshould reset the counter to 0.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n"}
{"input": "\nMake a decade counter that counts 1 through 10, inclusive. The reset\ninput is active high synchronous, and should reset the counter to 1.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 10)\n\t\t\tq <= 1;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n"}
{"input": "\nCreate a set of counters suitable for use as a 12-hour clock (with am/pm\nindicator). Your counters are clocked by a fast-running clk, with a pulse\non ena whenever your clock should increment (i.e., once per second, while\n\"clk\" is much faster than once per second). The signal \"pm\" is asserted\nif the clock is PM, or is otherwise AM. hh, mm, and ss are two BCD\n(Binary- Coded Decimal) digits each for hours (01-12), minutes (00-59),\nand seconds (00-59). Reset is the active high synchronous signal that\nresets the clock to \"12:00 AM.\" Reset has higher priority than enable and\ncan occur even when not enabled.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input ena,\n  output reg pm,\n  output reg [7:0] hh,\n  output reg [7:0] mm,\n  output reg [7:0] ss\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput ena,\n\toutput reg pm,\n\toutput reg [7:0] hh,\n\toutput reg [7:0] mm,\n\toutput reg [7:0] ss);\n\t\n\twire [6:0] enable = {\n\t\t{hh[7:0],mm[7:0],ss[7:0]}==24'h115959,\n\t\t{hh[3:0],mm[7:0],ss[7:0]}==20'h95959,\n\t\t{mm[7:0],ss[7:0]}==16'h5959,\n\t\t{mm[3:0],ss[7:0]}==12'h959,\n\t\tss[7:0]==8'h59, \n\t\tss[3:0] == 4'h9, \n\t\t1'b1};\n\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\t{pm,hh,mm,ss} <= 25'h0120000;\n\t\telse if (ena) begin\n\t\t\tif (enable[0] && ss[3:0] == 9) ss[3:0] <= 0;\n\t\t\telse if (enable[0]) ss[3:0] <= ss[3:0] + 1;\n\n\t\t\tif (enable[1] && ss[7:4] == 4'h5) ss[7:4] <= 0;\n\t\t\telse if (enable[1]) ss[7:4] <= ss[7:4] + 1;\n\t\t\t\n\t\t\tif (enable[2] && mm[3:0] == 9) mm[3:0] <= 0;\n\t\t\telse if (enable[2]) mm[3:0] <= mm[3:0] + 1;\n\n\t\t\tif (enable[3] && mm[7:4] == 4'h5) mm[7:4] <= 0;\n\t\t\telse if (enable[3]) mm[7:4] <= mm[7:4] + 1;\n\t\t\t\n\t\t\tif (enable[4] && hh[3:0] == 4'h9) hh[3:0] <= 0;\n\t\t\telse if (enable[4]) hh[3:0] <= hh[3:0] + 1;\n\n\t\t\tif (enable[4] && hh[7:0] == 8'h12) hh[7:0] <= 8'h1;\n\t\t\telse if (enable[5]) hh[7:4] <= hh[7:4] + 1;\n\t\t\t\n\t\t\tif (enable[6]) pm <= ~pm;\n\t\tend\nendmodule\n"}
{"input": "\nBuild a 4-digit BCD (binary-coded decimal) counter. Each decimal digit is\nencoded using 4 bits: q[3:0] is the ones digit, q[7:4] is the tens digit,\netc. For digits [3:1], also output an enable signal indicating when each\nof the upper three digits should be incremented. Include a synchronous\nactive-high reset.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output [3:1] ena,\n  output reg [15:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput [3:1] ena,\n\toutput reg [15:0] q);\n\t\n\twire [3:0] enable = { q[11:0]==12'h999, q[7:0]==8'h99, q[3:0] == 4'h9, 1'b1};\n\tassign ena = enable[3:1];\n\talways @(posedge clk)\n\t\tfor (int i=0;i<4;i++) begin\n\t\t\tif (reset || (q[i*4 +:4] == 9 && enable[i]))\n\t\t\t\tq[i*4 +:4] <= 0;\n\t\t\telse if (enable[i])\n\t\t\t\tq[i*4 +:4] <= q[i*4 +:4]+1;\n\t\tend\n\t\nendmodule\n"}
{"input": "\nBuild a two-bit saturating counter. The counter increments (up to a\nmaximum of 3) when train_valid = 1 and train_taken = 1. It decrements\n(down to a minimum of 0) when train_valid = 1 and train_taken = 0. When\nnot training (train_valid = 0), the counter keeps its value unchanged.\nareset is a positive edge triggered asynchronous reset that resets the\ncounter to weakly not-taken (2'b01). Output state[1:0] is the two-bit\ncounter value.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input train_valid,\n  input train_taken,\n  output logic [1:0] state\n);\n\n", "spec": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n", "output": "module top_module(\n    input clk,\n    input areset,\n    input train_valid,\n    input train_taken,\n    output logic [1:0] state\n);\n    always @(posedge clk, posedge areset) begin\n        if (areset)\n            state <= 1;\n        else if (train_valid) begin\n            if(state < 3 && train_taken)\n                state <= state + 1;\n            else if(state > 0 && !train_taken)\n                state <= state - 1;\n        end\n    end\nendmodule\n"}
{"input": "\nBuild a decade counter that counts from 0 through 9, inclusive, with a\nperiod of 10. The reset input is active high synchronous, and should\nreset the counter to 0. We want to be able to pause the counter rather\nthan always incrementing every clock cycle, so the \"slowena\" input if\nhigh indicates when the counter should increment.\n\nmodule TopModule (\n  input clk,\n  input slowena,\n  input reset,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput slowena,\n\tinput reset,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse if (slowena) begin\n\t\t\tif (q == 9)\n\t\t\t\tq <= 0;\n\t\t\telse\n\t\t\t\tq <= q+1;\n\t\tend\n\t\nendmodule\n"}
{"input": "\nCreate a single D flip-flop.\n\nmodule TopModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "output": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\t\n\tinitial\n\t\tq = 1'hx;\n\t\t\n\talways @(posedge clk)\n\t\tq <= d;\n\t\nendmodule\n"}
{"input": "\nCreate 16 D flip-flops. It's sometimes useful to only modify parts of a\ngroup of flip-flops. The byte-enable inputs control whether each byte of\nthe 16 registers should be written to on that cycle. byteena[1] controls\nthe upper byte d[15:8], while byteena[0] controls the lower byte d[7:0].\nresetn is a synchronous, active-low reset. All DFFs should be triggered\nby the positive edge of clk.\n\nmodule TopModule (\n  input clk,\n  input resetn,\n  input [1:0] byteena,\n  input [15:0] d,\n  output reg [15:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput resetn,\n\tinput [1:0] byteena,\n\tinput [15:0] d,\n\toutput reg [15:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (!resetn)\n\t\t\tq <= 0;\n\t\telse begin\n\t\t\tif (byteena[0])\n\t\t\t\tq[7:0] <= d[7:0];\n\t\t\tif (byteena[1])\n\t\t\t\tq[15:8] <= d[15:8];\n\t\tend\n\tend\n\t\nendmodule\n"}
{"input": "\nCreate 8 D flip-flops. All DFFs should be triggered by the positive edge\nof clk.\n\nmodule TopModule (\n  input clk,\n  input [7:0] d,\n  output reg [7:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\toutput reg [7:0] q);\n\t\n\tinitial\n\t\tq = 8'h0;\n\t\t\n\talways @(posedge clk)\n\t\tq <= d;\n\t\nendmodule\n"}
{"input": "\nCreate 8 D flip-flops with active high asynchronous reset. The output\nshould be reset to 0. All DFFs should be triggered by the positive edge\nof clk.\n\nmodule TopModule (\n  input clk,\n  input [7:0] d,\n  input areset,\n  output reg [7:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\t\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n"}
{"input": "\nCreate 8 D flip-flops with active high synchronous reset. The flip-flops\nmust be reset to 0x34 rather than zero. All DFFs should be triggered by\nthe negative edge of clk.\n\nmodule TopModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(negedge clk)\n\t\tif (reset)\n\t\t\tq <= 8'h34;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n"}
{"input": "\nCreate 8 D flip-flops with active high synchronous reset setting the\noutput to zero. All DFFs should be triggered by the positive edge of clk.\n\nmodule TopModule (\n  input clk,\n  input [7:0] d,\n  input reset,\n  output reg [7:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput reset,\n\toutput reg [7:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n"}
{"input": "\nA dual-edge triggered flip-flop is triggered on both edges of the clock.\nHowever, FPGAs don't have dual-edge triggered flip-flops, and always\n@(posedge clk or negedge clk) is not accepted as a legal sensitivity\nlist. Build a circuit that functionally behaves like a dual-edge\ntriggered flip-flop.\n\nmodule TopModule (\n  input clk,\n  input d,\n  output reg q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n", "output": "module top_module(\n\tinput clk,\n\tinput d,\n\toutput reg q);\n\t\n\t/*always @(posedge clk, negedge clk) begin\n\t\tq <= d;\n\tend*/\n\n\treg qp, qn;\n    always @(posedge clk)\n        qp <= d;\n    always @(negedge clk)\n        qn <= d;\n    // assign q = clk ? qp : qn;  // This causes q to change too early when clk changes. Need delay by delta cycle\n    always @(*)\n        q <= clk ? qp : qn;\nendmodule\n"}
{"input": "\nIn this question, you will design a circuit for an 8x1 memory, where\nwriting to the memory is accomplished by shifting-in bits, and reading is\n\"random access\", as in a typical RAM. You will then use the circuit to\nrealize a 3-input logic function. First, create an 8-bit shift register\nwith 8 D-type flip-flops. Label the flip-flop outputs from Q[0]...Q[7].\nThe shift register input should be called S, which feeds the input of\nQ[0] (MSB is shifted in first). The enable input is synchronous active\nhigh and controls whether to shift. Extend the circuit to have 3\nadditional inputs A,B,C and an output Z. The circuit's behaviour should\nbe as follows: when ABC is 000, Z=Q[0], when ABC is 001, Z=Q[1], and so\non. Your circuit should contain ONLY the 8-bit shift register, and\nmultiplexers.\n\nmodule TopModule (\n  input clk,\n  input enable,\n  input S,\n  input A,\n  input B,\n  input C,\n  output reg Z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput enable,\n\tinput S,\n\tinput A,\n\tinput B,\n\tinput C,\n\toutput reg Z\n);\n\n\treg [7:0] q;\n\talways @(posedge clk) begin\n\t\tif (enable)\n\t\t\tq <= {q[6:0], S};\n\tend\n\t\n\tassign Z = q[ {A, B, C} ];\n\t\nendmodule\n"}
{"input": "\nA single-output digital system with four inputs (a,b,c,d) generates a\nlogic-1 when 2, 7, or 15 appears on the inputs, and a logic-0 when 0, 1,\n4, 5, 6, 9, 10, 13, or 14 appears. The input conditions for the numbers\n3, 8, 11, and 12 never occur in this system. For example, 7 corresponds\nto a,b,c,d being set to 0,1,1,1, respectively. Determine the output\nout_sop in minimum sum-of-products form, and the output out_pos in\nminimum product-of-sums form.\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out_sop,\n  output out_pos\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out_sop,\n\toutput out_pos\n);\n\t\n\twire pos0, pos1;\n\tassign out_sop = c&d | ~a&~b&c;\n\tassign pos0 = c & (~b|d)&(~a|b);\n\tassign pos1 = c & (~b|d)&(~a|d);\n\t\n\tassign out_pos = (pos0 == pos1) ? pos0 : 1'bx;\nendmodule\n"}
{"input": "\nA large reservior of water serves several users. In order to keep the\nlevel of water succificently high, three sensors are placed vertically at\n5-inch intervals. When the water level is above the highest sensor s[3],\nthe input flow rate should be zero. When the level is below the lowest\nsensor s[1], the flow rate should be at maximum (both Nominal flow valve\nand Supplemental flow valve opened). The flow rate when the level is\nbetween the upper and lower sensors is determined by two factors: the\nwater level and the level previous to the last sensor change. Each water\nlevel has a nominal flow rate associated with it as show in the table\nbelow. If the sensor change indicates that the previous level was lower\nthan the current level, the flow rate should be increased by opening the\nSupplemental flow valve (controlled by dfr).\n\n  Water Level           | Sensors Asserted | Nominal Flow Rate Inputs to be Asserted\n  Above s[3]            | s[1], s[2], s[3] | None\n  Between s[3] and s[2] | s[1], s[2]       | fr1\n  Between s[2] and s[1] | s[1]             | fr1, fr2\n  Below s[1]            | None             | fr1, fr2, fr3\n\nAlso include an active-high synchronous reset that resets the state\nmachine to a state equivalent to if the water level had been low for a\nlong time (no sensors asserted, and all four outputs asserted).\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input [3:1] s,\n  output reg fr3,\n  output reg fr2,\n  output reg fr1,\n  output reg dfr\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput [3:1] s,\n\toutput reg fr3,\n\toutput reg fr2,\n\toutput reg fr1,\n\toutput reg dfr\n);\n\tparameter A2=0, B1=1, B2=2, C1=3, C2=4, D1=5;\n\treg [2:0] state, next;\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) state <= A2;\n\t\telse state <= next;\n\tend\n\t\n\talways@(*) begin\n\t\tcase (state)\n\t\t\tA2: next = s[1] ? B1 : A2;\n\t\t\tB1: next = s[2] ? C1 : (s[1] ? B1 : A2);\n\t\t\tB2: next = s[2] ? C1 : (s[1] ? B2 : A2);\n\t\t\tC1: next = s[3] ? D1 : (s[2] ? C1 : B2);\n\t\t\tC2: next = s[3] ? D1 : (s[2] ? C2 : B2);\n\t\t\tD1: next = s[3] ? D1 : C2;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\treg [3:0] fr;\n\tassign {fr3, fr2, fr1, dfr} = fr;\n\talways_comb begin\n\t\tcase (state)\n\t\t\tA2: fr = 4'b1111;\n\t\t\tB1: fr = 4'b0110;\n\t\t\tB2: fr = 4'b0111;\n\t\t\tC1: fr = 4'b0010;\n\t\t\tC2: fr = 4'b0011;\n\t\t\tD1: fr = 4'b0000;\n\t\t\tdefault: fr = 'x;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nA JK flip-flop has the below truth table. Note: Qold is the output of the\nflip-flop before the positive clock edge.\n\n  J | K | Q\n  0 | 0 | Qold\n  0 | 1 | 0\n  1 | 0 | 1\n  1 | 1 | ~Qold\n\nmodule TopModule (\n  input clk,\n  input j,\n  input k,\n  output reg Q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\toutput reg Q\n);\n\n\talways @(posedge clk)\n\t\tQ <= j&~Q | ~k&Q;\n\t\nendmodule\n"}
{"input": "\nImplement a Mealy-type finite state machine that recognizes the sequence\n\"101\" on an input signal named x. Your FSM should have an output signal,\nz, that is asserted to logic-1 when the \"101\" sequence is detected. Your\nFSM should also have a negative edge triggered asynchronous reset. You\nmay only have 3 states in your state machine. Your FSM should recognize\noverlapping sequences.\n\nmodule TopModule (\n  input clk,\n  input aresetn,\n  input x,\n  output reg z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput aresetn,\n\tinput x,\n\toutput reg z\n);\n\tparameter S=0, S1=1, S10=2;\n\treg[1:0] state, next;\n\t\n\talways@(posedge clk, negedge aresetn)\n\t\tif (!aresetn)\n\t\t\tstate <= S;\n\t\telse\n\t\t\tstate <= next;\n\t\t\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = x ? S1 : S;\n\t\t\tS1: next = x ? S1 : S10;\n\t\t\tS10: next = x ? S1 : S;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: z = 0;\n\t\t\tS1: z = 0;\n\t\t\tS10: z = x;\n\t\t\tdefault: z = 'x;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nAssume that you have two 8-bit 2's complement numbers, a[7:0] and b[7:0].\nThese numbers are added to produce s[7:0]. Also compute whether a\n(signed) overflow has occurred.\n\nmodule TopModule (\n  input [7:0] a,\n  input [7:0] b,\n  output [7:0] s,\n  output overflow\n);\n\n", "spec": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n", "output": "module top_module (\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput [7:0] s,\n\toutput overflow\n);\n\t\n\twire [8:0] sum = a+b;\n\tassign s = sum[7:0];\n\tassign overflow = !(a[7]^b[7]) && (a[7] != s[7]);\n\t\nendmodule\n"}
{"input": "\nFor the following Karnaugh map, give the circuit implementation using one\n4-to-1 multiplexer and as many 2-to-1 multiplexers as required, but using\nas few as possible. You are not allowed to use any other logic gate and\nyou must use _a_ and _b_ as the multiplexer selector inputs, as shown on\nthe 4-to-1 multiplexer below.\n\n      ab\n  cd  00  01  11  10\n  00 | 0 | 0 | 0 | 1 |\n  01 | 1 | 0 | 0 | 0 |\n  11 | 1 | 0 | 1 | 1 |\n  10 | 1 | 0 | 0 | 1 |\n\nConsider a block diagram with inputs 'c' and 'd' going into a module\ncalled \"top_module\". This \"top_module\" has four outputs, mux_in[3:0],\nthat connect to a four input mux. The mux takes as input {a,b} and ab =\n00 is connected to mux_in[0], ab=01 is connected to mux_in[1], and so in.\nYou are implementing in Verilog just the portion labelled \"top_module\",\nsuch that the entire circuit (including the 4-to-1 mux) implements the\nK-map.\n\nmodule TopModule (\n  input c,\n  input d,\n  output [3:0] mux_in\n);\n\n", "spec": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n", "output": "module top_module (\n\tinput c,\n\tinput d,\n\toutput [3:0] mux_in\n);\n\t\n\tassign mux_in[0] = c | d;\n\tassign mux_in[1] = 0;\n\tassign mux_in[2] = ~d;\t\n\tassign mux_in[3] = c&d;\n\t\nendmodule\n"}
{"input": "\nGiven the finite state machine circuit described below, assume that the D\nflip-flops are initially reset to zero before the machine begins.\n\nBuild this circuit in Verilog.\n\nInput x goes to three different two-input gates: a XOR, an AND, and a OR\ngate. Each of the three gates is connected to the input of a D flip-flop\nand then the flip-flop outputs all go to a three-input NOR, whose output\nis Z. The second input of the XOR is its corresponding flip-flop's\noutput, the second input of the AND is its corresponding flip-flop's\ncomplemented output, and finally the second input of the OR is its\ncorresponding flip-flop's complementary output.\n\nmodule TopModule (\n  input clk,\n  input x,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput x,\n\toutput z\n);\n\t\n\treg [2:0] s = 0;\n\t\n\talways @(posedge clk) begin\n\t\ts <= { s[2] ^ x, ~s[1] & x, ~s[0] | x };\t\t\n\tend\n\t\n\tassign z = ~|s;\n\t\nendmodule\n"}
{"input": "\nYou are to design a one-input one-output serial 2's complementer Moore\nstate machine. The input (x) is a series of bits (one per clock cycle)\nbeginning with the least-significant bit of the number, and the output\n(Z) is the 2's complement of the input. The machine will accept input\nnumbers of arbitrary length. The circuit requires a positive edge\ntriggered asynchronous reset. The conversion begins when Reset is\nreleased and stops when Reset is asserted.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n\tparameter A=0,B=1,C=2;\n\treg [1:0] state;\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tA: state <= x ? C : A;\n\t\t\t\tB: state <= x ? B : C;\n\t\t\t\tC: state <= x ? B : C;\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\tassign z = (state == C);\n\t\nendmodule\n"}
{"input": "\nThe following diagram is a Mealy machine implementation of the 2's\ncomplementer. Implement in Verilog using one-hot encoding. Resets into\nstate A and reset is asynchronous active-high.\n\n  A --x=0 (z=0)--> A\n  A --x=1 (z=1)--> B\n  B --x=0 (z=1)--> B\n  B --x=1 (z=0)--> B\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input x,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput x,\n\toutput z\n);\n\n\tparameter A=0,B=1;\n\treg state;\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset)\n\t\t\tstate <= A;\n\t\telse begin\n\t\t\tcase (state)\n\t\t\t\tA: state <= x ? B : A;\n\t\t\t\tB: state <= B;\n\t\t\tendcase\n\t\tend\n\tend\n\t\n\tassign z = (state == A && x==1) | (state == B && x==0);\n\t\nendmodule\n"}
{"input": "\nFor each bit in a 32-bit vector, capture when the input signal changes\nfrom 1 in one clock cycle to 0 the next. \"Capture\" means that the output\nwill remain 1 until the register is reset (active high synchronous\nreset).\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input [31:0] in,\n  output reg [31:0] out\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput [31:0] in,\n\toutput reg [31:0] out);\n\t\n\treg [31:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tif (reset)\n\t\t\tout <= '0;\n\t\telse\n\t\t\tout <= out | (~in & d_last);\n\tend\n\t\nendmodule\n"}
{"input": "\nFor each bit in an 8-bit vector, detect when the input signal changes\nfrom 0 in one clock cycle to 1 the next (similar to positive edge\ndetection). The output bit should be set the cycle after a 0 to 1\ntransition occurs.\n\nmodule TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] pedge\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] pedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tpedge <= in & ~d_last;\n\tend\n\t\nendmodule\n"}
{"input": "\nFor each bit in an 8-bit vector, detect when the input signal changes\nfrom one clock cycle to the next (detect any edge). The output bit should\nbe set the cycle after a 0 to 1 or 1 to 0 transition occurs.\n\nmodule TopModule (\n  input clk,\n  input [7:0] in,\n  output reg [7:0] anyedge\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n", "output": "module top_module(\n\tinput clk,\n\tinput [7:0] in,\n\toutput reg [7:0] anyedge);\n\t\n\treg [7:0] d_last;\t\n\t\t\t\n\talways @(posedge clk) begin\n\t\td_last <= in;\n\t\tanyedge <= in ^ d_last;\n\tend\n\t\nendmodule\n"}
{"input": "\nCreate a full adder. A full adder adds three bits (including carry-in)\nand produces a sum and carry-out.\n\nmodule TopModule (\n  input a,\n  input b,\n  input cin,\n  output cout,\n  output sum\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput cin,\n\toutput cout,\n\toutput sum\n);\n\n\tassign {cout, sum} = a+b+cin;\n\t\nendmodule\n"}
{"input": "\nConsider the follow Moore machine with the diagram described below:\n\n  B (1) --0--> A\n  B (1) --1--> B\n  A (0) --0--> B\n  A (0) --1--> A\n\nWrite Verilog implementing this state machine. It should asynchronously\nreset into state B if reset if high.\n\nmodule TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\tparameter A=0, B=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = in ? A : B;\n\t\t\tB: next = in ? B : A;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= B;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==B);\n\n\t\nendmodule\n"}
{"input": "\nThis is a Moore state machine with two states, one input, and one output.\nImplement this state machine in Verilog. The reset state is B and reset\nis active-high synchronous.\n\n  B (out=1) --in=0--> A\n  B (out=1) --in=1--> B\n  A (out=0) --in=0--> B\n  A (out=0) --in=1--> A\n\nmodule TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\tparameter A=0, B=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = in ? A : B;\n\t\t\tB: next = in ? B : A;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= B;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==B);\n\n\t\nendmodule\n"}
{"input": "\nThis is a Moore state machine with two states, two inputs, and one\noutput. Implement this state machine in Verilog. Reset is an active-high\nasynchronous reset to state OFF.\n\n  OFF (out=0) --j=0--> OFF\n  OFF (out=0) --j=1--> ON\n  ON  (out=1) --k=0--> ON\n  ON  (out=1) --k=1--> OFF\n\nmodule TopModule (\n  input clk,\n  input j,\n  input k,\n  input areset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput areset,\n\toutput out\n);\n\tparameter A=0, B=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = j ? B : A;\n\t\t\tB: next = k ? A : B;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= A;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==B);\n\n\t\nendmodule\n"}
{"input": "\nThis is a Moore state machine with two states, two inputs, and one\noutput. Implement this state machine in Verilog. Reset is an active-high\nsynchronous reset to state OFF.\n\n  OFF (out=0) --j=0--> OFF\n  OFF (out=0) --j=1--> ON\n  ON  (out=1) --k=0--> ON\n  ON  (out=1) --k=1--> OFF\n\nmodule TopModule (\n  input clk,\n  input j,\n  input k,\n  input reset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput j,\n\tinput k,\n\tinput reset,\n\toutput out\n);\n\tparameter A=0, B=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = j ? B : A;\n\t\t\tB: next = k ? A : B;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= A;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==B);\n\n\t\nendmodule\n"}
{"input": "\nThe following is the state transition table for a Moore state machine\nwith one input, one output, and four states. Implement this state\nmachine. Include a positive edge triggered asynchronous reset that resets\nthe FSM to state A.\n\n  state | next state in=0, next state in=1 | output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1\n\nmodule TopModule (\n  input clk,\n  input in,\n  input areset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput areset,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = in ? B : A;\n\t\t\tB: next = in ? B : C;\n\t\t\tC: next = in ? D : A;\n\t\t\tD: next = in ? B : C;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= A;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==D);\n\t\nendmodule\n"}
{"input": "\nThe following is the state transition table for a Moore state machine\nwith one input, one output, and four states. Use the following state\nencoding: A=2'b00, B=2'b01, C=2'b10, D=2'b11.Implement only the state\ntransition logic and output logic (the combinational logic portion) for\nthis state machine. Given the current state (state), compute the\nnext_state and output (out) based on the state transition table.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1\n\nmodule TopModule (\n  input in,\n  input [1:0] state,\n  output reg [1:0] next_state,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n", "output": "module top_module (\n\tinput in,\n\tinput [1:0] state,\n\toutput reg [1:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next_state = in ? B : A;\n\t\t\tB: next_state = in ? B : C;\n\t\t\tC: next_state = in ? D : A;\n\t\t\tD: next_state = in ? B : C;\n\t\tendcase\n    end\n    \n\tassign out = (state==D);\n\t\nendmodule\n"}
{"input": "\nThe following is the state transition table for a Moore state machine\nwith one input, one output, and four states. Use the following one-hot\nstate encoding: A=4'b0001, B=4'b0010, C=4'b0100, D=4'b1000. Derive state\ntransition and output logic equations by inspection assuming a one-hot\nencoding. Implement only the state transition logic and output logic (the\ncombinational logic portion) for this state machine.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1\n\nmodule TopModule (\n  input in,\n  input [3:0] state,\n  output reg [3:0] next_state,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n", "output": "module top_module (\n\tinput in,\n\tinput [3:0] state,\n\toutput reg [3:0] next_state,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n    \n    assign next_state[A] = (state[A] | state[C]) & ~in;\n    assign next_state[B] = (state[A] | state[B] | state[D]) & in;\n    assign next_state[C] = (state[B] | state[D]) & ~in;\n    assign next_state[D] = state[C] & in;\n    \n\tassign out = (state[D]);\n\t\nendmodule\n"}
{"input": "\nThe following is the state transition table for a Moore state machine\nwith one input, one output, and four states. Implement this state\nmachine. Include a synchronous active high reset that resets the FSM to\nstate A.\n\n  State | Next state in=0, Next state in=1 | Output\n  A     | A, B                             | 0\n  B     | C, B                             | 0\n  C     | A, D                             | 0\n  D     | C, B                             | 1\n\nmodule TopModule (\n  input clk,\n  input in,\n  input reset,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput out\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tA: next = in ? B : A;\n\t\t\tB: next = in ? B : C;\n\t\t\tC: next = in ? D : A;\n\t\t\tD: next = in ? B : C;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= A;\n        else state <= next;\n\tend\n\t\t\n\tassign out = (state==D);\n\t\nendmodule\n"}
{"input": "\nSynchronous HDLC framing involves decoding a continuous bit stream of\ndata to look for bit patterns that indicate the beginning and end of\nframes (packets). Seeing exactly 6 consecutive 1s (i.e., 01111110) is a\n\"flag\" that indicate frame boundaries. To avoid the data stream from\naccidentally containing \"flags\", the sender inserts a zero after every 5\nconsecutive 1s which the receiver must detect and discard. We also need\nto signal an error if there are 7 or more consecutive 1s. Create a\nMoore-type finite state machine to recognize these three sequences:\n\n  (1) 0111110: Signal a bit needs to be discarded (disc).\n  (2) 01111110: Flag the beginning/end of a frame (flag).\n  (3) 01111111...: Error (7 or more 1s) (err).\n\nWhen the FSM is reset, it should be in a state that behaves as though the\nprevious input were 0. The reset signal is active high synchronous. The\noutput signals should be asserted for a complete cycle beginning on the\nclock cycle after the condition occurs.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input in,\n  output disc,\n  output flag,\n  output err\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n\t\n\tparameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n\treg [3:0] state, next;\n\n\tassign disc = state == SDISC;\n\tassign flag = state == SFLAG;\n\tassign err = state == SERR;\n\t\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tS0: state <= in ? S1 : S0;\n\t\t\tS1: state <= in ? S2 : S0;\n\t\t\tS2: state <= in ? S3 : S0;\n\t\t\tS3: state <= in ? S4 : S0;\n\t\t\tS4: state <= in ? S5 : S0;\n\t\t\tS5: state <= in ? S6 : SDISC;\n\t\t\tS6: state <= in ? SERR : SFLAG;\n\t\t\tSERR: state <= in ? SERR : S0;\n\t\t\tSFLAG: state <= in ? S1 : S0;\n\t\t\tSDISC: state <= in ? S1 : S0;\n\t\t\tdefault: state <= 'x;\n\t\tendcase\n\t\t\n\t\tif (reset) state <= S0;\n\tend\n\t\nendmodule\n"}
{"input": "\nGiven the follow state machine with 1 input and 2 outputs (the outputs\nare given as \"(out1, out2)\"):\n\n  S0 (0, 0) --0--> S0\n  S0 (0, 0) --1--> S1\n  S1 (0, 0) --0--> S0\n  S1 (0, 0) --1--> S2\n  S2 (0, 0) --0--> S0\n  S2 (0, 0) --1--> S3\n  S3 (0, 0) --0--> S0\n  S3 (0, 0) --1--> S4\n  S4 (0, 0) --0--> S0\n  S4 (0, 0) --1--> S5\n  S5 (0, 0) --0--> S8\n  S5 (0, 0) --1--> S6\n  S6 (0, 0) --0--> S9\n  S6 (0, 0) --1--> S7\n  S7 (0, 1) --0--> S0\n  S7 (0, 1) --1--> S7\n  S8 (1, 0) --0--> S0\n  S8 (1, 0) --1--> S1\n  S9 (1, 1) --0--> S0\n  S9 (1, 1) --1--> S1\n\nSuppose this state machine uses one-hot encoding, where state[0] through\nstate[9] correspond to the states S0 though S9, respectively. The outputs\nare zero unless otherwise specified.\n\nWrite Verilog implementing the state transition logic and output logic\nportions of the state machine (but not the state flip-flops). You are\ngiven the current state in state[9:0] and must produce next_state[9:0]\nand the two outputs. Derive the logic equations by inspection assuming a\none-hot encoding.\n\nmodule TopModule (\n  input in,\n  input [9:0] state,\n  output [9:0] next_state,\n  output out1,\n  output out2\n);\n\n", "spec": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n", "output": "module top_module (\n\tinput in,\n\tinput [9:0] state,\n\toutput [9:0] next_state,\n\toutput out1,\n\toutput out2);\n\t\n\tassign out1 = state[8] | state[9];\n\tassign out2 = state[7] | state[9];\n\n\tassign next_state[0] = !in && (|state[4:0] | state[7] | state[8] | state[9]);\n\tassign next_state[1] = in && (state[0] | state[8] | state[9]);\n\tassign next_state[2] = in && state[1];\n\tassign next_state[3] = in && state[2];\n\tassign next_state[4] = in && state[3];\n\tassign next_state[5] = in && state[4];\n\tassign next_state[6] = in && state[5];\n\tassign next_state[7] = in && (state[6] | state[7]);\n\tassign next_state[8] = !in && state[5];\n\tassign next_state[9] = !in && state[6];\n\n\t\nendmodule\n"}
{"input": "\nThe PS/2 mouse protocol sends messages that are three bytes long.\nHowever, within a continuous byte stream, it's not obvious where messages\nstart and end. The only indication is that the first byte of each three\nbyte message always has in[3]=1 (but in[3] of the other two bytes may be\n1 or 0 depending on data). We want a finite state machine that will\nsearch for message boundaries when given an input byte stream. The\nalgorithm we'll use is to discard bytes until we see one with in[3]=1. We\nthen assume that this is byte 1 of a message, and signal the receipt of a\nmessage once all 3 bytes have been received (done). The FSM should signal\ndone in the cycle immediately after the third byte of each message was\nsuccessfully received. Reset should be active high synchronous.\n\nmodule TopModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output done\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput done\n);\n\tparameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    wire in3 = in[3];\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tBYTE1: next = in3 ? BYTE2 : BYTE1;\n\t\t\tBYTE2: next = BYTE3;\n\t\t\tBYTE3: next = DONE;\n\t\t\tDONE: next = in3 ? BYTE2 : BYTE1;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= BYTE1;\n        else state <= next;\n\tend\n\t\t\n\tassign done = (state==DONE);\n\t\nendmodule\n"}
{"input": "\nWe want a finite state machine that will search for message boundaries\nwhen given an input byte stream. The algorithm we'll use is to discard\nbytes until we see one with in[3]=1. We then assume that this is byte 1\nof a message, and signal the receipt of a message once all 3 bytes have\nbeen received (done). The FSM should signal done in the cycle immediately\nafter the third byte of each message was successfully received.\n\nImplement the datapath module that will output the 24-bit (3 byte)\nmessage whenever a packet is received (out_bytes[23:16] is the first\nbyte, out_bytes[15:8] is the second byte, etc.). The reset signal is\nactive high synchronous. out_bytes needs to be valid whenever the done\nsignal is asserted. You may output anything at other times (i.e.,\ndon't-care).\n\n  Waveform example:\n  time   clk rst in  done out_bytes\n  0ns    0   1    0  x         x\n  5ns    1   1    0  0         x\n  10ns   0   1    0  0         x\n  15ns   1   0   2c  0         x\n  20ns   0   0   2c  0         x\n  25ns   1   0   81  0         x\n  30ns   0   0   81  0         x\n  35ns   1   0    9  0         x\n  40ns   0   0    9  0         x\n  45ns   1   0   6b  1    2c8109\n  50ns   0   0   6b  1    2c8109\n  55ns   1   0    d  0         x\n  60ns   0   0    d  0         x\n  65ns   1   0   8d  0         x\n  70ns   0   0   8d  0         x\n  75ns   1   0   6d  1    6b0d8d\n  80ns   0   0   6d  1    6b0d8d\n  85ns   1   0   12  0         x\n  90ns   0   0   12  0         x\n  95ns   1   0    1  0         x\n  100ns  0   0    1  0         x\n  105ns  1   0    d  1    6d1201\n  110ns  0   0    d  1    6d1201\n  115ns  1   0   76  0         x\n  120ns  0   0   76  0         x\n  125ns  1   0   3d  0         x\n  130ns  0   0   3d  0         x\n  135ns  1   0   ed  1     d763d\n  140ns  0   0   ed  1     d763d\n  145ns  1   0   8c  0         x\n  150ns  0   0   8c  0         x\n  155ns  1   0   f9  0         x\n  160ns  0   0   f9  0         x\n  165ns  1   0   ce  1    ed8cf9\n  170ns  0   0   ce  1    ed8cf9\n  175ns  1   0   c5  0         x\n  180ns  0   0   c5  0         x\n  185ns  1   0   aa  0         x\n  190ns  0   0   aa  0         x\n\nmodule TopModule (\n  input clk,\n  input [7:0] in,\n  input reset,\n  output [23:0] out_bytes,\n  output done\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput [7:0] in,\n\tinput reset,\n\toutput [23:0] out_bytes,\n\toutput done\n);\n\tparameter BYTE1=0, BYTE2=1, BYTE3=2, DONE=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    wire in3 = in[3];\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tBYTE1: next = in3 ? BYTE2 : BYTE1;\n\t\t\tBYTE2: next = BYTE3;\n\t\t\tBYTE3: next = DONE;\n\t\t\tDONE: next = in3 ? BYTE2 : BYTE1;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= BYTE1;\n        else state <= next;\n\tend\n\t\t\n\tassign done = (state==DONE);\n\t\n\treg [23:0] out_bytes_r;\n\talways @(posedge clk)\n\t\tout_bytes_r <= {out_bytes_r[15:0], in};\n\t\n\t// Implementations may vary: Allow user to do anything while the output doesn't have to be valid.\t\n\tassign out_bytes = done ? out_bytes_r : 'x;\t\t\n\t\nendmodule\n"}
{"input": "\nIn many (older) serial communications protocols, each data byte is sent\nalong with a start bit and a stop bit, to help the receiver delimit bytes\nfrom the stream of bits. One common scheme is to use one start bit (0), 8\ndata bits, and 1 stop bit (1). The line is also at logic 1 when nothing\nis being transmitted (idle). Design a finite state machine that will\nidentify when bytes have been correctly received when given a stream of\nbits. It needs to identify the start bit, wait for all 8 data bits, then\nverify that the stop bit was correct. If the stop bit does not appear\nwhen expected, the FSM must wait until it finds a stop bit before\nattempting to receive the next byte. Include a active-high synchronous\nreset. Note that the serial protocol sends the least significant bit\nfirst.\n\nmodule TopModule (\n  input clk,\n  input in,\n  input reset,\n  output done\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput done\n);\n\tparameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n\treg [3:0] state;\n\treg [3:0] next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tSTART: next = in ? START : B0;\t// start bit is 0\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = B4;\n\t\t\tB4: next = B5;\n\t\t\tB5: next = B6;\n\t\t\tB6: next = B7;\n\t\t\tB7: next = STOP;\n\t\t\tSTOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n\t\t\tDONE: next = in ? START : B0;\n\t\t\tERR: next = in ? START : ERR;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= START;\n        else state <= next;\n\tend\n\t\t\n\tassign done = (state==DONE);\n\t\nendmodule\n"}
{"input": "\nIn many (older) serial communications protocols, each data byte is sent\nalong with a start bit and a stop bit, to help the receiver delimit bytes\nfrom the stream of bits. One common scheme is to use one start bit (0), 8\ndata bits, and 1 stop bit (1). The line is also at logic 1 when nothing\nis being transmitted (idle). Design a finite state machine that will\nidentify when bytes have been correctly received when given a stream of\nbits. It needs to identify the start bit, wait for all 8 data bits, then\nverify that the stop bit was correct. The module will also output the\ncorrectly- received data byte. out_byte needs to be valid when done is 1,\nand is don't-care otherwise.If the stop bit does not appear when\nexpected, the FSM must wait until it finds a stop bit before attempting\nto receive the next byte. Include a active-high synchronous reset. Note\nthat the serial protocol sends the least significant bit first. It should\nassert done each time it finds a stop bit.\n\nmodule TopModule (\n  input clk,\n  input in,\n  input reset,\n  output [7:0] out_byte,\n  output done\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\tinput reset,\n\toutput [7:0] out_byte,\n\toutput done\n);\n\tparameter B0=0, B1=1, B2=2, B3=3, B4=4, B5=5, B6=6, B7=7, START=8, STOP=9, DONE=10, ERR=11;\n\treg [3:0] state;\n\treg [3:0] next;\n    \n    reg [9:0] byte_r;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tSTART: next = in ? START : B0;\t// start bit is 0\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = B4;\n\t\t\tB4: next = B5;\n\t\t\tB5: next = B6;\n\t\t\tB6: next = B7;\n\t\t\tB7: next = STOP;\n\t\t\tSTOP: next = in ? DONE : ERR;  // stop bit is 1. Idle state is 1.\n\t\t\tDONE: next = in ? START : B0;\n\t\t\tERR: next = in ? START : ERR;\n\t\tendcase\n    end\n    \n    always @(posedge clk) begin\n\t\tif (reset) state <= START;\n        else state <= next;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tbyte_r <= {in, byte_r[9:1]};\n\tend\n\t\t\n\tassign done = (state==DONE);\n\tassign out_byte = done ? byte_r[8:1] : 8'hx;\n\t\nendmodule\n"}
{"input": "\nBuild a combinational circuit with two inputs, a and b. There are 7\noutputs, each with a logic gate driving it:\n\n  (1) out_and: a and b\n  (2) out_or: a or b\n  (3) out_xor: a xor b\n  (4) out_nand: a nand b\n  (5) out_nor: a nor b\n  (6) out_xnor: a xnor b\n  (7) out_anotb: a and-not b\n\nmodule TopModule (\n  input a,\n  input b,\n  output out_and,\n  output out_or,\n  output out_xor,\n  output out_nand,\n  output out_nor,\n  output out_xnor,\n  output out_anotb\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor,\n\toutput out_nand,\n\toutput out_nor,\n\toutput out_xnor,\n\toutput out_anotb\n);\n\n\tassign out_and = a&b;\n\tassign out_or = a|b;\n\tassign out_xor = a^b;\n\tassign out_nand = ~(a&b);\n\tassign out_nor = ~(a|b);\n\tassign out_xnor = a^~b;\n\tassign out_anotb = a & ~b;\n\t\nendmodule\n"}
{"input": "\nBuild a combinational circuit with 100 inputs, in[99:0]. There are 3\noutputs:\n\n  (1) out_and: output of a 100-input AND gate.\n  (2) out_or: output of a 100-input OR gate.\n  (3) out_xor: output of a 100-input XOR gate.\n\nmodule TopModule (\n  input [99:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n", "spec": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "output": "module top_module (\n\tinput [99:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n"}
{"input": "\nBuild a combinational circuit with four inputs, in[3:0]. There are 3\noutputs:\n\n  (1) out_and: output of a 4-input AND gate.\n  (2) out_or: output of a 4-input OR gate.\n  (3) out_xor: output of a 4-input XOR gate.\n\nmodule TopModule (\n  input [3:0] in,\n  output out_and,\n  output out_or,\n  output out_xor\n);\n\n", "spec": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n", "output": "module top_module (\n\tinput [3:0] in,\n\toutput out_and,\n\toutput out_or,\n\toutput out_xor\n);\n\n\tassign out_and = &in;\n\tassign out_or = |in;\n\tassign out_xor = ^in;\n\t\nendmodule\n"}
{"input": "\nYou are given a four-bit input vector in[3:0]. We want to know some\nrelationships between each bit and its neighbour:\n\n  (1) out_both: Each bit of this output vector should indicate whether\n  both the corresponding input bit and its neighbour to the left (higher\n  index) are '1'. For example, out_both[2] should indicate if in[2] and\n  in[3] are both 1. Since in[3] has no neighbour to the left, the answer\n  is obvious so we don't need to know out_both[3].\n\n  (2) out_any: Each bit of this output vector should indicate whether any\n  of the corresponding input bit and its neighbour to the right are '1'.\n  For example, out_any[2] should indicate if either in[2] or in[1] are 1.\n  Since in[0] has no neighbour to the right, the answer is obvious so we\n  don't need to know out_any[0].\n\n  (3) out_different: Each bit of this output vector should indicate\n  whether the corresponding input bit is different from its neighbour to\n  the left. For example, out_different[2] should indicate if in[2] is\n  different from in[3]. For this part, treat the vector as wrapping\n  around, so in[3]'s neighbour to the left is in[0].\n\nmodule TopModule (\n  input [3:0] in,\n  output [2:0] out_both,\n  output [3:1] out_any,\n  output [3:0] out_different\n);\n\n", "spec": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "output": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n"}
{"input": "\nYou are given a 100-bit input vector in[99:0]. We want to know some\nrelationships between each bit and its neighbour:\n\n  (1) out_both: Each bit of this output vector should indicate whether\n  both the corresponding input bit and its neighbour to the left are '1'.\n  For example, out_both[98] should indicate if in[98] and in[99] are both\n  1. Since in[99] has no neighbour to the left, the answer is obvious so\n  we don't need to know out_both[99].\n\n  (2) out_any: Each bit of this output vector should indicate whether any\n  of the corresponding input bit and its neighbour to the right are '1'.\n  For example, out_any[2] should indicate if either in[2] or in[1] are 1.\n  Since in[0] has no neighbour to the right, the answer is obvious so we\n  don't need to know out_any[0].\n\n  (3) out_different: Each bit of this output vector should indicate\n  whether the corresponding input bit is different from its neighbour to\n  the left. For example, out_different[98] should indicate if in[98] is\n  different from in[99]. For this part, treat the vector as wrapping\n  around, so in[99]'s neighbour to the left is in[0].\n\nmodule TopModule (\n  input [99:0] in,\n  output [98:0] out_both,\n  output [99:1] out_any,\n  output [99:0] out_different\n);\n\n", "spec": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n", "output": "module top_module (\n\tinput [99:0] in,\n\toutput [98:0] out_both,\n\toutput [99:1] out_any,\n\toutput [99:0] out_different\n);\n\n\tassign out_both = in & in[99:1];\n\tassign out_any = in | in[99:1];\n\tassign out_different = in^{in[0], in[99:1]};\n\t\nendmodule\n"}
{"input": "\nBuild a gshare branch predictor with 7-bit pc and 7-bit global history,\nhashed (using xor) into a 7-bit index. This index accesses a 128-entry\ntable of two-bit saturating counters. The branch predictor should contain\na 7-bit global branch history register. The branch predictor has two sets\nof interfaces: One for doing predictions and one for doing training. The\nprediction interface is used in the processor's Fetch stage to ask the\nbranch predictor for branch direction predictions for the instructions\nbeing fetched. Once these branches proceed down the pipeline and are\nexecuted, the true outcomes of the branches become known. The branch\npredictor is then trained using the actual branch direction outcomes.\n\nWhen a branch prediction is requested (predict_valid = 1) for a given pc,\nthe branch predictor produces the predicted branch direction and state of\nthe branch history register used to make the prediction. The branch\nhistory register is then updated (at the next positive clock edge) for\nthe predicted branch.\n\nWhen training for a branch is requested (train_valid = 1), the branch\npredictor is told the pc and branch history register value for the branch\nthat is being trained, as well as the actual branch outcome and whether\nthe branch was a misprediction (needing a pipeline flush). Update the\npattern history table (PHT) to train the branch predictor to predict this\nbranch more accurately next time. In addition, if the branch being\ntrained is mispredicted, also recover the branch history register to the\nstate immediately after the mispredicting branch completes execution.\n\nIf training for a misprediction and a prediction (for a different,\nyounger instruction) occurs in the same cycle, both operations will want\nto modify the branch history register. When this happens, training takes\nprecedence, because the branch being predicted will be discarded anyway.\nIf training and prediction of the same PHT entry happen at the same time,\nthe prediction sees the PHT state before training because training only\nmodifies the PHT at the next positive clock edge. The following timing\ndiagram shows the timing when training and predicting PHT entry 0 at the\nsame time. The training request at cycle 4 changes the PHT entry state in\ncycle 5, but the prediction request in cycle 4 outputs the PHT state at\ncycle 4, without considering the effect of the training request in cycle\n4. Reset is asynchronous active-high.\n\nmodule TopModule (\n  input clk,\n  input areset,\n\n  input predict_valid,\n  input [6:0] predict_pc,\n  output predict_taken,\n  output [6:0] predict_history,\n\n  input train_valid,\n  input train_taken,\n  input train_mispredicted,\n  input [6:0] train_history,\n  input [6:0] train_pc\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n", "output": "module top_module(\n\tinput clk,\n\tinput areset, \n\n\tinput predict_valid,\n\tinput [6:0] predict_pc,\n\toutput predict_taken, \n\toutput [6:0] predict_history,\n\n\tinput train_valid,\n\tinput train_taken,\n\tinput train_mispredicted,\n\tinput [6:0] train_history, \n\tinput [6:0] train_pc\n);\n\tparameter n = 7;\n\tlogic [1:0] pht [2**n-1:0];\n\n\tparameter [1:0] SNT = 0, LNT = 1, LT = 2, ST = 3;\n\n\tlogic [n-1:0] predict_history_r;\n\twire [n-1:0] predict_index = predict_history_r ^ predict_pc;\n\twire [n-1:0] train_index = train_history ^ train_pc;\n\t\n\talways@(posedge clk, posedge areset)\n\t\tif (areset) begin\n\t\t\tfor (integer i=0; i<2**n; i=i+1)\n\t\t\t\tpht[i] = LNT;\n\t\t\tpredict_history_r = 0;\n        end\telse begin\n\t\t\tif (predict_valid)\n\t\t\t\tpredict_history_r <= {predict_history_r, predict_taken};\n\t\t\tif(train_valid) begin\n\t\t\t\tif(pht[train_index] < 3 && train_taken)\n\t\t\t\t\tpht[train_index] <= pht[train_index] + 1;\n\t\t\t\telse if(pht[train_index] > 0 && !train_taken)\n\t\t\t\t\tpht[train_index] <= pht[train_index] - 1;\n\t\t\t\tif (train_mispredicted)\n\t\t\t\t\tpredict_history_r <= {train_history, train_taken};\n\t\t\tend\n\t\tend\n\n\tassign predict_taken = predict_valid ? pht[predict_index][1] : 1'bx;\n\tassign predict_history = predict_valid ? predict_history_r : {n{1'bx}};\nendmodule\n"}
{"input": "\nCreate a half adder. A half adder adds two bits (with no carry-in) and\nproduces a sum and carry-out.\n\nmodule TopModule (\n  input a,\n  input b,\n  output sum,\n  output cout\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\toutput sum,\n\toutput cout\n);\n\n\tassign {cout, sum} = a+b;\n\t\nendmodule\n"}
{"input": "\nBuild a 32-bit global history shift register, including support for\nrolling back state in response to a pipeline flush caused by a branch\nmisprediction. When a branch prediction is made (predict_valid = 1),\nshift in predict_taken from the LSB side to update the branch history for\nthe predicted branch. (predict_history[0] is the direction of the\nyoungest branch.) When a branch misprediction occurs (train_mispredicted\n= 1), load the branch history register with the history after the\ncompletion of the mispredicted branch. This is the history before the\nmispredicted branch (train_history) concatenated with the actual result\nof the branch (train_taken). If both a prediction and misprediction occur\nat the same time, the misprediction takes precedence, because the\npipeline flush will also flush out the branch that is currently making a\nprediction. predict_history is the value of the branch history register.\nareset is a positive edge triggered asynchronous reset that resets the\nhistory counter to zero.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input predict_valid,\n  input predict_taken,\n  output logic [31:0] predict_history,\n\n  input train_mispredicted,\n  input train_taken,\n  input [31:0] train_history\n);\n\n", "spec": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n", "output": "module top_module\n(\n    input clk,\n    input areset,\n    input predict_valid,\n    input predict_taken,\n    output logic [31:0] predict_history,\n    \n    input train_mispredicted,\n    input train_taken,\n    input [31:0] train_history\n);\n    always@(posedge clk, posedge areset)\n\t\tif (areset) begin\n\t\t\tpredict_history = 0;\n        end\telse begin\n\t\t\tif (train_mispredicted)\n\t\t\t\tpredict_history <= {train_history, train_taken};\n\t\t\telse if (predict_valid)\n\t\t\t\tpredict_history <= {predict_history, predict_taken};\n\t\tend\nendmodule\n"}
{"input": "\nImplement the circuit described by the Karnaugh map below.\n\n          a\n   bc   0   1\n   00 | 0 | 1 |\n   01 | 1 | 1 |\n   11 | 1 | 1 |\n   10 | 1 | 1 |\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n", "output": "module top_module(\n\tinput a, \n\tinput b,\n\tinput c,\n\toutput out\n);\n\t\n\tassign out = (a | b | c);\n\t\nendmodule\n"}
{"input": "\nImplement the circuit described by the Karnaugh map below.\n\n              ab\n   cd   00  01  11  10\n   00 | 1 | 1 | 0 | 1 |\n   01 | 1 | 0 | 0 | 1 |\n   11 | 0 | 1 | 1 | 1 |\n   10 | 1 | 1 | 0 | 0 |\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out\n);\n\t\n\tassign out = (~c & ~b) | (~d&~a) | (a&c&d) | (b&c&d);\n\t\nendmodule\n"}
{"input": "\nImplement the circuit described by the Karnaugh map below. d is\ndon't-care, which means you may choose to output whatever value is\nconvenient.\n\n              ab\n   cd   01  00  10  11\n   00 | d | 0 | 1 | 1 |\n   01 | 0 | 0 | d | d |\n   11 | 0 | 1 | 1 | 1 |\n   10 | 0 | 1 | 1 | 1 |\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n"}
{"input": "\nImplement the circuit described by the Karnaugh map below.\n\n             ab\n  cd   00  01  11  10\n  00 | 0 | 1 | 0 | 1 |\n  01 | 1 | 0 | 1 | 0 |\n  11 | 0 | 1 | 0 | 1 |\n  10 | 1 | 0 | 1 | 0 |\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output reg out\n);\n\n", "spec": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "output": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 1;\n            4'h3: out = 0;\n            4'h2: out = 1;\n            4'h4: out = 1;\n            4'h5: out = 0;\n            4'h7: out = 1;\n            4'h6: out = 0;\n            4'hc: out = 0;\n            4'hd: out = 1;\n            4'hf: out = 0;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 0;\n            4'hb: out = 1;\n            4'ha: out = 0;\n        endcase\n    end\nendmodule\n"}
{"input": "\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections. Implement a Moore state machine with two states, two inputs,\nand one output (internal to the module) that models this behaviour.\nareset is positive edge triggered asynchronous reseting the Lemming\nmachine to walk left.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  output walk_left,\n  output walk_right\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\tparameter WL=0, WR=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = bump_left ? WR : WL;\n\t\t\tWR: next = bump_right ? WL: WR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\n\t\nendmodule\n"}
{"input": "\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"aaah!\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  output walk_left,\n  output walk_right,\n  output aaah\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah\n);\n\tparameter WL=0, WR=1, FALLL=2, FALLR=3;\n\treg [1:0] state;\n\treg [1:0] next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = ground ? (bump_left ? WR : WL) : FALLL;\n\t\t\tWR: next = ground ? (bump_right ? WL: WR) : FALLR;\n\t\t\tFALLL: next = ground ? WL : FALLL;\n\t\t\tFALLR: next = ground ? WR : FALLR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\tassign aaah = (state == FALLL) || (state == FALLR);\n\t\nendmodule\n"}
{"input": "\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"aaah!\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nIn addition to walking and falling, Lemmings can sometimes be told to do\nuseful things, like dig (it starts digging when dig=1). A Lemming can dig\nif it is currently walking on ground (ground=1 and not falling), and will\ncontinue digging until it reaches the other side (ground=0). At that\npoint, since there is no ground, it will fall (aaah!), then continue\nwalking in its original direction once it hits ground again. As with\nfalling, being bumped while digging has no effect, and being told to dig\nwhen falling or when there is no ground is ignored. (In other words, a\nwalking Lemming can fall, dig, or switch directions. If more than one of\nthese conditions are satisfied, fall has higher precedence than dig,\nwhich has higher precedence than switching directions.)\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\tparameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5;\n\treg [2:0] state;\n\treg [2:0] next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: if (!ground) next = FALLL;\n\t\t\t\telse if (dig) next = DIGL;\n\t\t\t\telse if (bump_left) next = WR;\n\t\t\t\telse next = WL;\n\t\t\tWR: \n\t\t\t\tif (!ground) next = FALLR;\n\t\t\t\telse if (dig) next = DIGR;\n\t\t\t\telse if (bump_right) next = WL;\n\t\t\t\telse next = WR;\n\t\t\tFALLL: next = ground ? WL : FALLL;\n\t\t\tFALLR: next = ground ? WR : FALLR;\n\t\t\tDIGL: next = ground ? DIGL : FALLL;\n\t\t\tDIGR: next = ground ? DIGR : FALLR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\tassign aaah = (state == FALLL) || (state == FALLR);\n\tassign digging = (state == DIGL) || (state == DIGR);\n\t\nendmodule\n"}
{"input": "\nThe game Lemmings involves critters with fairly simple brains. So simple\nthat we are going to model it using a finite state machine. In the\nLemmings' 2D world, Lemmings can be in one of two states: walking left\n(walk_left is 1) or walking right (walk_right is 1). It will switch\ndirections if it hits an obstacle. In particular, if a Lemming is bumped\non the left (by receiving a 1 on bump_left), it will walk right. If it's\nbumped on the right (by receiving a 1 on bump_right), it will walk left.\nIf it's bumped on both sides at the same time, it will still switch\ndirections.\n\nIn addition to walking left and right and changing direction when bumped,\nwhen ground=0, the Lemming will fall and say \"\"aaah!\"\". When the ground\nreappears (ground=1), the Lemming will resume walking in the same\ndirection as before the fall. Being bumped while falling does not affect\nthe walking direction, and being bumped in the same cycle as ground\ndisappears (but not yet falling), or when the ground reappears while\nstill falling, also does not affect the walking direction.\n\nIn addition to walking and falling, Lemmings can sometimes be told to do\nuseful things, like dig (it starts digging when dig=1). A Lemming can dig\nif it is currently walking on ground (ground=1 and not falling), and will\ncontinue digging until it reaches the other side (ground=0). At that\npoint, since there is no ground, it will fall (aaah!), then continue\nwalking in its original direction once it hits ground again. As with\nfalling, being bumped while digging has no effect, and being told to dig\nwhen falling or when there is no ground is ignored. (In other words, a\nwalking Lemming can fall, dig, or switch directions. If more than one of\nthese conditions are satisfied, fall has higher precedence than dig,\nwhich has higher precedence than switching directions.)\n\nAlthough Lemmings can walk, fall, and dig, Lemmings aren't invulnerable.\nIf a Lemming falls for too long then hits the ground, it can splatter. In\nparticular, if a Lemming falls for more than 20 clock cycles then hits\nthe ground, it will splatter and cease walking, falling, or digging (all\n4 outputs become 0), forever (Or until the FSM gets reset). There is no\nupper limit on how far a Lemming can fall before hitting the ground.\nLemmings only splatter when hitting the ground; they do not splatter in\nmid-air.\n\nImplement a Moore state machine that models this behaviour. areset is\npositive edge triggered asynchronous reseting the Lemming machine to walk\nleft.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input bump_left,\n  input bump_right,\n  input ground,\n  input dig,\n  output walk_left,\n  output walk_right,\n  output aaah,\n  output digging\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\tinput ground,\n\tinput dig,\n\toutput walk_left,\n\toutput walk_right,\n\toutput aaah,\n\toutput digging\n);\n\tparameter WL=0, WR=1, FALLL=2, FALLR=3, DIGL=4, DIGR=5, DEAD=6;\n\treg [2:0] state;\n\treg [2:0] next;\n    \n    reg [4:0] fall_counter;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: if (!ground) next = FALLL;\n\t\t\t\telse if (dig) next = DIGL;\n\t\t\t\telse if (bump_left) next = WR;\n\t\t\t\telse next = WL;\n\t\t\tWR: \n\t\t\t\tif (!ground) next = FALLR;\n\t\t\t\telse if (dig) next = DIGR;\n\t\t\t\telse if (bump_right) next = WL;\n\t\t\t\telse next = WR;\n\t\t\tFALLL: next = ground ? (fall_counter >= 20 ? DEAD : WL) : FALLL;\n\t\t\tFALLR: next = ground ? (fall_counter >= 20 ? DEAD : WR) : FALLR;\n\t\t\tDIGL: next = ground ? DIGL : FALLL;\n\t\t\tDIGR: next = ground ? DIGR : FALLR;\n\t\t\tDEAD: next = DEAD;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (state == FALLL || state == FALLR) begin\n\t\t\tif (fall_counter < 20)\n\t\t\t\tfall_counter <= fall_counter + 1'b1;\n\t\tend\n\t\telse\n\t\t\tfall_counter <= 0;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\tassign aaah = (state == FALLL) || (state == FALLR);\n\tassign digging = (state == DIGL) || (state == DIGR);\n\t\nendmodule\n"}
{"input": "\nA linear feedback shift register is a shift register usually with a few\nXOR gates to produce the next state of the shift register. A Galois LFSR\nis one particular arrangement that shifts right, where a bit position with\na \"tap\" is XORed with the LSB output bit (q[0]) to produce its next value,\nwhile bit positions without a tap shift right unchanged.  Build a 32-bit Galois\nLFSR with taps at bit positions 32, 22, 2, and 1. Reset should be active high\nsynchronous, and should reset the output q to 32'h1.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [31:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [31:0] q);\n\t\n\tlogic [31:0] q_next;\n\talways@(q) begin\n\t\tq_next = q[31:1];\n\t\tq_next[31] = q[0];\n\t\tq_next[21] ^= q[0];\n\t\tq_next[1] ^= q[0];\n\t\tq_next[0] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 32'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n"}
{"input": "\nA linear feedback shift register is a shift register usually with a few\nXOR gates to produce the next state of the shift register. A Galois LFSR\nis one particular arrangement that shifts right, where a bit position with\na \"tap\" is XORed with the LSB output bit (q[0]) to produce its next value,\nwhile bit positions without a tap shift right unchanged. If the taps positions\nare carefully chosen, the LFSR can be made to be \"maximum-length\". A maximum-length\nLFSR of n bits cycles through 2**n-1 states before repeating (the all-zero state is\nnever reached). Build a 5-bit maximal-length Galois LFSR with taps at bit\npositions 5 and 3. The active-high synchronous reset should reset the\nLFSR output to 1.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [4:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [4:0] q);\n\t\n\tlogic [4:0] q_next;\n\talways @(q) begin\n\t\tq_next = q[4:1];\n\t\tq_next[4] = q[0];\n\t\tq_next[2] ^= q[0];\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset)\n\t\t\tq <= 5'h1;\n\t\telse\n\t\t\tq <= q_next;\n\tend\nendmodule\n"}
{"input": "\nConsider the function f shown in the Karnaugh map below. d is don't-care,\nwhich means you may choose to output whatever value is convenient.\nImplement this function.\n\n                x[1]x[2]\n  x[3]x[4]   00  01  11  10\n        00 | d | 0 | d | d |\n        01 | 0 | d | 1 | 0 |\n        11 | 1 | 1 | d | d |\n        10 | 1 | 1 | 0 | d |\n\nmodule TopModule (\n  input [4:1] x,\n  output logic f\n);\n\n", "spec": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n", "output": "module top_module (\n\tinput [4:1] x,\n\toutput logic f\n);\n\n\talways_comb begin\n\t\tcase (x) \n\t\t\t4'h0: f = 1'bx;\n\t\t\t4'h1: f = 1'bx;\n\t\t\t4'h2: f = 0;\n\t\t\t4'h3: f = 1'bx;\n\t\t\t4'h4: f = 1;\n\t\t\t4'h5: f = 1'bx;\n\t\t\t4'h6: f = 1;\n\t\t\t4'h7: f = 0;\n\t\t\t4'h8: f = 0;\n\t\t\t4'h9: f = 0;\n\t\t\t4'ha: f = 1'bx;\n\t\t\t4'hb: f = 1;\n\t\t\t4'hc: f = 1;\n\t\t\t4'hd: f = 1'bx;\n\t\t\t4'he: f = 1;\n\t\t\t4'hf: f = 1'bx;\n\t\tendcase\n\tend\n\nendmodule\n"}
{"input": "\nImplement a D latch using an always block.\n\nmodule TopModule (\n  input d,\n  input ena,\n  output logic q\n);\n\n", "spec": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n", "output": "module top_module (\n\tinput d,\n\tinput ena,\n\toutput logic q\n);\n\n\talways@(*) begin\n\t\tif (ena)\n\t\t\tq = d;\n\tend\n\nendmodule\n"}
{"input": "\nImplement a D flip flop, positive edge triggered, with an asynchronous\nreset \"ar\".\n\nmodule TopModule (\n  input clk,\n  input d,\n  input ar,\n  output logic q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput ar,\n\toutput logic q\n);\n\n\talways@(posedge clk or posedge ar) begin\n\t\tif (ar)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"input": "\nImplement a simple D flip flop with active high synchronous reset (reset\noutput to 0).\n\nmodule TopModule (\n  input clk,\n  input d,\n  input r,\n  output logic q\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput d,\n\tinput r,\n\toutput logic q\n);\n\n\talways@(posedge clk) begin\n\t\tif (r)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\tend\n\nendmodule\n"}
{"input": "\nImplement in Verilog the following circuit: A D flip-flop takes as input\nthe output of a two-input XOR. The flip-flop is positive edge triggered\nby clk, but there is no reset. The XOR takes as input 'in' along with the\noutput 'out' of the flip-flop.\n\nmodule TopModule (\n  input clk,\n  input in,\n  output logic out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput in,\n\toutput logic out\n);\n\n\tinitial\n\t\tout = 0;\n\t\t\n\talways@(posedge clk) begin\n\t\tout <= in ^ out;\n\tend\n\nendmodule\n"}
{"input": "\nImplement a 2-input NOR gate.\n\nmodule TopModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n", "spec": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "output": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = ~(in1 | in2);\nendmodule\n"}
{"input": "\nImplement the following circuit in Verilog. Two inputs (in1 and in2) go\nto an AND gate, but the in2 input to the AND gate has a bubble. The\noutput of the AND gate is connected to 'out'.\n\nmodule TopModule (\n  input in1,\n  input in2,\n  output logic out\n);\n\n", "spec": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n", "output": "module top_module (\n\tinput in1,\n\tinput in2,\n\toutput logic out\n);\n\n\tassign out = in1 & ~in2;\nendmodule\n"}
{"input": "\nImplement in Verilog the following circuit: A two-input XNOR (connected\nto 'in1' and 'in2) has an output connected to the input of a two-input\nXOR. The second input of the XOR is 'in3.' The output of the XOR is\n'out'.\n\nmodule TopModule (\n  input in1,\n  input in2,\n  input in3,\n  output logic out\n);\n\n", "spec": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n", "output": "module top_module (\n\tinput in1,\n\tinput in2,\n\tinput in3,\n\toutput logic out\n);\n\n\tassign out = (~(in1 ^ in2)) ^ in3;\nendmodule\n"}
{"input": "\nThe module assigns the output port to the same value as the input port\ncombinationally.\n\nmodule TopModule (\n  input in,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput in,\n\toutput out);\n", "output": "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n"}
{"input": "\nBuild a circuit with no inputs and one output. That output should always\ndrive 0 (or logic low).\n\nmodule TopModule (\n  output out\n);\n\n", "spec": "module top_module(\n\toutput out);\n", "output": "module top_module(\n\toutput out);\n\t\n\tassign out = 1'b0;\n\t\nendmodule\n"}
{"input": "\nImplement a 4-bit adder with full adders. The output sum should include\nthe overflow bit.\n\nmodule TopModule (\n  input [3:0] x,\n  input [3:0] y,\n  output [4:0] sum\n);\n\n", "spec": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n", "output": "module top_module (\n\tinput [3:0] x,\n\tinput [3:0] y,\n\toutput [4:0] sum\n);\n\n\tassign sum = x+y;\nendmodule\n"}
{"input": "\nImplement a shift register with four D flops. Reset is active-low\nsynchronous resettable.\n\nmodule TopModule (\n  input clk,\n  input resetn,\n  input in,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput in,\n\toutput out\n);\n\n\treg [3:0] sr;\n\talways @(posedge clk) begin\n\t\tif (~resetn)\n\t\t\tsr <= '0;\n\t\telse \n\t\t\tsr <= {sr[2:0], in};\n\tend\n\t\n\tassign out = sr[3];\n\t\n\nendmodule\n"}
{"input": "\nConsider the state machine shown below:\n\n  A (0) --0--> B\n  A (0) --1--> A\n  B (0) --0--> C\n  B (0) --1--> D\n  C (0) --0--> E\n  C (0) --1--> D\n  D (0) --0--> F\n  D (0) --1--> A\n  E (1) --0--> E\n  E (1) --1--> D\n  F (1) --0--> C\n  F (1) --1--> D\n\nImplement this state machine in Verilog.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input w,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n", "output": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput w,\n\toutput z\n);\n\tparameter A=0, B=1, C=2, D=3, E=4, F=5;\n\treg [2:0] state, next;\n\t\n\talways @(posedge clk)\n\t\tif (reset)\n\t\t\tstate <= A;\n\t\telse \n\t\t\tstate <= next;\n\t\t\t\n\t\t\t\n\talways_comb begin\n\t\tcase(state)\n\t\t\tA: next = w ? A : B;\n\t\t\tB: next = w ? D : C;\n\t\t\tC: next = w ? D : E;\n\t\t\tD: next = w ? A : F;\n\t\t\tE: next = w ? D : E;\n\t\t\tF: next = w ? D : C;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t\n\tassign z = (state == E || state == F);\n\nendmodule\n"}
{"input": "\nConsider the state machine shown below:\n\n  A (0) --0--> B\n  A (0) --1--> A\n  B (0) --0--> C\n  B (0) --1--> D\n  C (0) --0--> E\n  C (0) --1--> D\n  D (0) --0--> F\n  D (0) --1--> A\n  E (1) --0--> E\n  E (1) --1--> D\n  F (1) --0--> C\n  F (1) --1--> D\n\nAssume that you want to Implement the FSM using three flip-flops and\nstate codes y[3:1] = 000, 001, ..., 101 for states A, B, ..., F,\nrespectively. Implement just the next-state logic for y[2] in Verilog.\nThe output Y2 is y[2].\n\nmodule TopModule (\n  input [3:1] y,\n  input w,\n  output reg Y2\n);\n\n", "spec": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n", "output": "module top_module(\n\tinput [3:1] y,\n\tinput w,\n\toutput reg Y2);\n\t\n\talways_comb begin\n\t\tcase ({y, w})\n\t\t\t4'h0: Y2 = 1'b0;\n\t\t\t4'h1: Y2 = 1'b0;\n\t\t\t4'h2: Y2 = 1'b1;\n\t\t\t4'h3: Y2 = 1'b1;\n\t\t\t4'h4: Y2 = 1'b0;\n\t\t\t4'h5: Y2 = 1'b1;\n\t\t\t4'h6: Y2 = 1'b0;\n\t\t\t4'h7: Y2 = 1'b0;\n\t\t\t4'h8: Y2 = 1'b0;\n\t\t\t4'h9: Y2 = 1'b1;\n\t\t\t4'ha: Y2 = 1'b1;\n\t\t\t4'hb: Y2 = 1'b1;\n\t\t\tdefault: Y2 = 1'bx;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nConsider the state machine shown below:\n\n  A (0) --0--> B\n  A (0) --1--> A\n  B (0) --0--> C\n  B (0) --1--> D\n  C (0) --0--> E\n  C (0) --1--> D\n  D (0) --0--> F\n  D (0) --1--> A\n  E (1) --0--> E\n  E (1) --1--> D\n  F (1) --0--> C\n  F (1) --1--> D\n\nResets into state A. For this part, assume that a one-hot code is used\nwith the state assignment y[6:1] = 000001, 000010, 000100, 001000,\n010000, 100000 for states A, B,..., F, respectively.\n\nWrite Verilog for the next-state signals Y2 and Y4 corresponding to\nsignal y[2] and y[4]. Derive the logic equations by inspection assuming a\none-hot encoding.\n\nmodule TopModule (\n  input [6:1] y,\n  input w,\n  output Y2,\n  output Y4\n);\n\n", "spec": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n", "output": "module top_module (\n\tinput [6:1] y,\n\tinput w,\n\toutput Y2,\n\toutput Y4\n);\n\tassign Y2 = y[1]&~w;\n\tassign Y4 = (y[2]|y[3]|y[5]|y[6]) & w;\n\nendmodule\n"}
{"input": "\nCreate a circuit that has two 2-bit inputs A[1:0] and B[1:0], and\nproduces an output z. The value of z should be 1 if A = B, otherwise z\nshould be 0.\n\nmodule TopModule (\n  input [1:0] A,\n  input [1:0] B,\n  output z\n);\n\n", "spec": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n", "output": "module top_module(\n\tinput [1:0] A,\n\tinput [1:0] B,\n\toutput z);\n\n\tassign z = A[1:0]==B[1:0];\n\t\nendmodule\n"}
{"input": "\nConsider this Verilog module \"full_module\":\n\n  module full_module (\n      input [2:0] r, // load value\n      input L, // load\n      input clk, // clock\n      output reg [2:0] q // output\n\n    always @(posedge clk) begin\n      if (L) begin\n        q <= r;\n      end else begin\n        q <= {q[1] ^ q[2], q[0], q[2]};\n      end\n  end\n\n  endmodule\n\nNote that q[2:0] is three bits wide, representing three flip-flops that can be\nloaded from r when L is asserted. You want to factor full_module into a hierarchical\ndesign, flipflop and 2:1 multiplexer are in a submodule \"TopModule\", and that submodule\nwill be instantiated three times in full_module code. Create the submodule called \"TopModule\".\nYou do not have to provide the revised full_module.\n\nmodule TopModule (\n  input clk,\n  input L,\n  input q_in,\n  input r_in,\n  output reg Q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n", "output": "module top_module(\n\tinput clk,\n\tinput L,\n\tinput q_in,\n\tinput r_in,\n\toutput reg Q);\n\n\tinitial Q=0;\n\talways @(posedge clk)\n\t\tQ <= L ? r_in : q_in;\n\t\nendmodule\n"}
{"input": "\nModule A implements the boolean function z = (x^y) & x.\n\nModule B can be described by the following simulation waveform:\n\n  time  x  y  z\n  0ns   0  0  1\n  5ns   0  0  1\n  10ns  0  0  1\n  15ns  0  0  1\n  20ns  0  0  1\n  25ns  1  0  0\n  30ns  1  0  0\n  35ns  0  1  0\n  40ns  0  1  0\n  45ns  1  1  1\n  50ns  1  1  1\n  55ns  0  0  1\n  60ns  0  1  0\n  65ns  0  1  0\n  70ns  1  1  1\n  75ns  0  1  0\n  80ns  0  1  0\n  85ns  0  1  0\n  90ns  1  0  0\n\nNow consider a top-level that uses two A submodules and two B submodules.\nThe first input of all four submodules is connect to input 'x', and the\nsecond input of all four submodules is connected to 'y'. The output of\nthe first A submodule is connected to a two-input OR, along with the\noutput of the first B submodule. The second pair of A and B submodules is\nsimilarly connected to an AND gate. The output of the OR and the AND is\nconnected to an XOR, whose output is 'z'.\n\nImplement this circuit in Verilog.\n\nmodule TopModule (\n  input x,\n  input y,\n  output z\n);\n\n", "spec": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "output": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = x|~y;\n\t\nendmodule\n"}
{"input": "\nImplement the boolean function z = (x^y) & x.\n\nmodule TopModule (\n  input x,\n  input y,\n  output z\n);\n\n", "spec": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "output": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = (x^y) & x;\n\t\nendmodule\n"}
{"input": "\nThe module can be described by the following simulation waveform:\n\n  time  x  y  z\n  0ns   0  0  1\n  5ns   0  0  1\n  10ns  0  0  1\n  15ns  0  0  1\n  20ns  0  0  1\n  25ns  1  0  0\n  30ns  1  0  0\n  35ns  0  1  0\n  40ns  0  1  0\n  45ns  1  1  1\n  50ns  1  1  1\n  55ns  0  0  1\n  60ns  0  1  0\n  65ns  0  1  0\n  70ns  1  1  1\n  75ns  0  1  0\n  80ns  0  1  0\n  85ns  0  1  0\n  90ns  1  0  0\n\nmodule TopModule (\n  input x,\n  input y,\n  output z\n);\n\n", "spec": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n", "output": "module top_module(\n\tinput x,\n\tinput y,\n\toutput z);\n\n\tassign z = ~(x^y);\n\t\nendmodule\n"}
{"input": "\nCreate a 1-bit wide, 256-to-1 multiplexer. The 256 inputs are all packed\ninto a single 256-bit input vector. sel=0 should select in[0], sel=1\nselects bits in[1], sel=2 selects bits in[2], etc.\n\nmodule TopModule (\n  input [255:0] in,\n  input [7:0] sel,\n  output  out\n);\n\n", "spec": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n", "output": "module top_module (\n\tinput [255:0] in,\n\tinput [7:0] sel,\n\toutput  out\n);\n\n\tassign out = in[sel];\n\t\nendmodule\n"}
{"input": "\nCreate a 4-bit wide, 256-to-1 multiplexer. The 256 4-bit inputs are all\npacked into a single 1024-bit input vector. sel=0 should select bits\nin[3:0], sel=1 selects bits in[7:4], sel=2 selects bits in[11:8], etc.\n\nmodule TopModule (\n  input [1023:0] in,\n  input [7:0] sel,\n  output [3:0] out\n);\n\n", "spec": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n", "output": "module top_module (\n\tinput [1023:0] in,\n\tinput [7:0] sel,\n\toutput [3:0] out\n);\n\n\tassign out = {in[sel*4+3], in[sel*4+2], in[sel*4+1], in[sel*4+0]};\n\t\nendmodule\n"}
{"input": "\nCreate a one-bit wide, 2-to-1 multiplexer. When sel=0, choose a. When\nsel=1, choose b.\n\nmodule TopModule (\n  input a,\n  input b,\n  input sel,\n  output out\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput sel,\n\toutput out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n"}
{"input": "\nCreate a 2-1 multiplexer. When sel=0, choose a. When sel=1, choose b.\n\nmodule TopModule (\n  input [99:0] a,\n  input [99:0] b,\n  input sel,\n  output [99:0] out\n);\n\n", "spec": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n", "output": "module top_module (\n\tinput [99:0] a,\n\tinput [99:0] b,\n\tinput sel,\n\toutput [99:0] out\n);\n\n\tassign out = sel ? b : a;\n\t\nendmodule\n"}
{"input": "\nCreate a 16-bit wide, 9-to-1 multiplexer. sel=0 chooses a, sel=1 chooses\nb, etc. For the unused cases (sel=9 to 15), set all output bits to '1'.\n\nmodule TopModule (\n  input [15:0] a,\n  input [15:0] b,\n  input [15:0] c,\n  input [15:0] d,\n  input [15:0] e,\n  input [15:0] f,\n  input [15:0] g,\n  input [15:0] h,\n  input [15:0] i,\n  input [3:0] sel,\n  output logic [15:0] out\n);\n\n", "spec": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n", "output": "module top_module (\n\tinput [15:0] a,\n\tinput [15:0] b,\n\tinput [15:0] c,\n\tinput [15:0] d,\n\tinput [15:0] e,\n\tinput [15:0] f,\n\tinput [15:0] g,\n\tinput [15:0] h,\n\tinput [15:0] i,\n\tinput [3:0] sel,\n\toutput logic [15:0] out\n);\n\n\talways @(*) begin\n\t\tout = '1;\n\t\tcase (sel)\n\t\t\t4'h0: out = a;\n\t\t\t4'h1: out = b;\n\t\t\t4'h2: out = c;\n\t\t\t4'h3: out = d;\n\t\t\t4'h4: out = e;\n\t\t\t4'h5: out = f;\n\t\t\t4'h6: out = g;\n\t\t\t4'h7: out = h;\n\t\t\t4'h8: out = i;\n\t\tendcase\n\tend\n\t\nendmodule\n"}
{"input": "\nCreate a module that implements a NOR gate.\n\nmodule TopModule (\n  input a,\n  input b,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "output": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a | b);\n\t\nendmodule\n"}
{"input": "\nCreate a module that implements a NOT gate.\n\nmodule TopModule (\n  input in,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput in,\n\toutput out\n);\n", "output": "module top_module(\n\tinput in,\n\toutput out\n);\n\t\n\tassign out = ~in;\n\t\nendmodule\n"}
{"input": "\nA \"population count\" circuit counts the number of '1's in an input\nvector. Build a population count circuit for a 255-bit input vector.\n\nmodule TopModule (\n  input [254:0] in,\n  output reg [7:0] out\n);\n\n", "spec": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n", "output": "module top_module (\n\tinput [254:0] in,\n\toutput reg [7:0] out\n);\n\n\talways_comb  begin\n\t\tout = 0;\n\t\tfor (int i=0;i<255;i++)\n\t\t\tout = out + in[i];\n\tend\n\t\nendmodule\n"}
{"input": "\nA \"population count\" circuit counts the number of '1's in an input\nvector. Build a population count circuit for a 3-bit input vector.\n\nmodule TopModule (\n  input [2:0] in,\n  output [1:0] out\n);\n\n", "spec": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n", "output": "module top_module (\n\tinput [2:0] in,\n\toutput [1:0] out\n);\n\n\tassign out = in[0]+in[1]+in[2];\n\t\nendmodule\n"}
{"input": "\nParity checking is often used as a simple method of detecting errors when\ntransmitting data through an imperfect channel. Create a circuit that\nwill compute a parity bit for a 8-bit byte (which will add a 9th bit to\nthe byte). We will use \"even\" parity, where the parity bit is just the\nXOR of all 8 data bits.\n\nmodule TopModule (\n  input [7:0] in,\n  output parity\n);\n\n", "spec": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n", "output": "module top_module (\n\tinput [7:0] in,\n\toutput parity\n);\n\n\tassign parity = ^in;\n\t\nendmodule\n"}
{"input": "\nBuild a counter that counts from 0 to 999, inclusive, with a period of\n1000 cycles. The reset input is active high synchronous, and should reset\nthe counter to 0.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output reg [9:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 999)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n"}
{"input": "\nWe want to create a timer with one input that:\n\n  (1) is started when a particular input pattern (1101) is detected,\n  (2) shifts in 4 more bits to determine the duration to delay,\n  (3) waits for the counters to finish counting, and\n  (4) notifies the user and waits for the user to acknowledge the timer.\n\nThe serial data is available on the data input pin. When the pattern 1101\nis received, the circuit must then shift in the next 4 bits,\nmost-significant-bit first. These 4 bits determine the duration of the\ntimer delay, referred to as delay[3:0]. After that, the state machine\nasserts its counting output to indicate it is counting. Once the 1101 and\ndelay[3:0] have been read, the circuit no longer looks at the data input\nuntil it resumes searching after everything else is done.\n\nThe state machine must count for exactly (delay[3:0] + 1) * 1000 clock\ncycles. e.g., delay=0 means count 1000 cycles, and delay=5 means count\n6000 cycles. Also output the current remaining time. This should be equal\nto delay for 1000 cycles, then delay-1 for 1000 cycles, and so on until\nit is 0 for 1000 cycles.\n\nWhen the circuit isn't counting, the count[3:0] output is don't-care\n(whatever value is convenient for you to implement). At that point, the\ncircuit must assert done to notify the user the timer has timed out, and\nwaits until input ack is 1 before being reset to look for the next\noccurrence of the start sequence (1101).\n\nThe circuit should reset into a state where it begins searching for the\ninput sequence 1101. The reset signal is active high synchronous.\n\nmodule TopModule (\n  input wire clk,\n  input wire reset,\n  input wire data,\n  output wire [3:0] count,\n  output reg counting,\n  output reg done,\n  input wire ack\n);\n\n", "spec": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n", "output": "module top_module(\n\tinput wire clk,\n\tinput wire reset,\n\tinput wire data,\n    output wire [3:0] count,\n    output reg counting,\n    output reg done,\n    input wire ack );\n\n\ttypedef enum logic[3:0] {\n\t\tS, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n\t} States;\n\t\n\tStates state, next;\n\t\n\treg shift_ena;\n\treg [9:0] fcount;\n\treg [3:0] scount;\n\twire done_counting = (scount == 0) && (fcount == 999);\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = States'(data ? S1: S);\n\t\t\tS1: next = States'(data ? S11: S);\n\t\t\tS11: next = States'(data ? S11 : S110);\n\t\t\tS110: next = States'(data ? B0 : S);\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Count;\n\t\t\tCount: next = States'(done_counting ? Wait : Count);\n\t\t\tWait: next = States'(ack ? S : Wait);\n\t\t\tdefault: next = States'(4'bx);\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\tend\n\t\t\n\talways_comb begin\n\t\tshift_ena = 0; counting = 0; done = 0;\n\t\tif (state == B0 || state == B1 || state == B2 || state == B3)\n\t\t\tshift_ena = 1;\n\t\tif (state == Count)\n\t\t\tcounting = 1;\n\t\tif (state == Wait)\n\t\t\tdone = 1;\n\n\t\tif (|state === 1'bx) begin\n\t\t\t{shift_ena, counting, done} = 'x;\n\t\tend\t\t\n\tend\n\t\n\t\n\t// Shift register\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tscount <= {scount[2:0], data};\n\t\telse if (counting && fcount == 999)\n\t\t\tscount <= scount - 1'b1;\n\tend\n\t\n\t// Fast counter\n\talways @(posedge clk)\n\t\tif (!counting)\n\t\t\tfcount <= 10'h0;\n\t\telse if (fcount == 999)\n\t\t\tfcount <= 10'h0;\n\t\telse\n\t\t\tfcount <= fcount + 1'b1;\n\t\n\tassign count = counting ? scount : 'x;\n\t\n\t\nendmodule\n"}
{"input": "\nWe want to create a timer that:\n\n  (1) is started when a particular pattern (1101) is detected,\n  (2) shifts in 4 more bits to determine the duration to delay,\n  (3) waits for the counters to finish counting, and\n  (4) notifies the user and waits for the user to acknowledge the timer.\n\nIn this problem, implement just the finite-state machine that controls\nthe timer. The data path (counters and some comparators) are not included\nhere.\n\nThe serial data is available on the data input pin. When the pattern 1101\nis received, the state machine must then assert output shift_ena for\nexactly 4 clock cycles. After that, the state machine asserts its\ncounting output to indicate it is waiting for the counters, and waits\nuntil input done_counting is high.At that point, the state machine must\nassert done to notify the user the timer has timed out, and waits until\ninput ack is 1 before being reset to look for the next occurrence of the\nstart sequence (1101). The state machine should have a active high\nsynchronous reset, setting the state to where it begins searching for the\ninput sequence 1101.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input data,\n  output reg shift_ena,\n  output reg counting,\n  input done_counting,\n  output reg done,\n  input ack\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n    output reg shift_ena,\n    output reg counting,\n    input done_counting,\n    output reg done,\n    input ack );\n\n\ttypedef enum logic[3:0] {\n\t\tS, S1, S11, S110, B0, B1, B2, B3, Count, Wait\n\t} States;\n\t\n\tStates state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = States'(data ? S1: S);\n\t\t\tS1: next = States'(data ? S11: S);\n\t\t\tS11: next = States'(data ? S11 : S110);\n\t\t\tS110: next = States'(data ? B0 : S);\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Count;\n\t\t\tCount: next = States'(done_counting ? Wait : Count);\n\t\t\tWait: next = States'(ack ? S : Wait);\n\t\t\tdefault: next = States'(4'bx);\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk) begin\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\tend\n\t\t\n\talways_comb begin\n\t\tshift_ena = 0; counting = 0; done = 0;\n\t\tif (state == B0 || state == B1 || state == B2 || state == B3)\n\t\t\tshift_ena = 1;\n\t\tif (state == Count)\n\t\t\tcounting = 1;\n\t\tif (state == Wait)\n\t\t\tdone = 1;\n\n\t\tif (|state === 1'bx) begin\n\t\t\t{shift_ena, counting, done} = 'x;\n\t\tend\n\t\t\n\tend\n\t\n\t\nendmodule\n"}
{"input": "\nGiven the following Moore state machine with 3 input (d, done_counting,\nack) and 3 outputs (shift_ena, counting, done). Unless otherwise stated in\nthe diagram below, assume outputs are 0 and inputs are don't cares.\n\nstate   (output)      --input--> next state\n-------------------------------------------\n  S     ()            --d=0--> S\n  S     ()            --d=1--> S1\n  S1    ()            --d=0--> S\n  S1    ()            --d=1--> S11\n  S11   ()            --d=0--> S110\n  S11   ()            --d=1--> S11\n  S110  ()            --d=0--> S\n  S110  ()            --d=1--> B0\n  B0    (shift_ena=1) --(always go to next cycle)--> B1\n  B1    (shift_ena=1) --(always go to next cycle)--> B2\n  B2    (shift_ena=1) --(always go to next cycle)--> B3\n  B3    (shift_ena=1) --(always go to next cycle)--> Count\n  Count (counting=1)  --done_counting=0--> Count\n  Count (counting=1)  --done_counting=1--> Wait\n  Wait  (done=1)      --ack=0--> Wait\n  Wait  (done=1)      --ack=1--> S\n\nAt reset, the state machine starts in state \"S\". Derive next-state logic\nequations and output logic equations by inspection assuming the following\none-hot encoding is used: (S, S1, S11, S110, B0, B1, B2, B3, Count, Wait)\n= (10'b0000000001, 10'b0000000010, 10'b0000000100, ... , 10'b1000000000)\n\nDerive state transition and output logic equations by inspection assuming\na one-hot encoding. Implement only the state transition logic and output\nlogic (the combinational logic portion) for this state machine.\n\nWrite code that generates the following signals:\n\n - B3_next -- Assert when next-state is B3 state\n - S_next -- Assert when next-state is S state\n - S1_next -- Assert when next-state is S1 state\n - Count_next -- Assert when next-state is Count state\n - Wait_next -- Assert when next-state is Wait state\n - done -- output logic\n - counting -- output logic\n - shift_ena -- output logic\n\nmodule TopModule (\n  input d,\n  input done_counting,\n  input ack,\n  input [9:0] state, // 10-bit one-hot current state\n  output B3_next,\n  output S_next,\n  output S1_next,\n  output Count_next,\n  output Wait_next,\n  output done,\n  output counting,\n  output shift_ena\n);\n\n", "spec": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "output": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\tparameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n"}
{"input": "\nBuild a finite-state machine that searches for the sequence 1101 in an\ninput bit stream. When the sequence is found, it should set\nstart_shifting to 1, forever, until reset. Reset is active high\nsynchronous.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  input data,\n  output start_shifting\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\tinput data,\n\toutput start_shifting);\n\n\tparameter S=0, S1=1, S11=2, S110=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tS: next = data ? S1: S;\n\t\t\tS1: next = data ? S11: S;\n\t\t\tS11: next = data ? S11 : S110;\n\t\t\tS110: next = data ? Done : S;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= S;\n\t\telse state <= next;\n\t\t\n\tassign start_shifting = state == Done;\n\t\n\t\nendmodule\n"}
{"input": "\nThis module is a part of the FSM for controlling the shift register, we\nwant the ability to enable the shift register for exactly 4 clock cycles\nwhenever the proper bit pattern is detected. Whenever the FSM is reset,\nassert shift_ena for 4 cycles, then 0 forever (until reset). Reset should\nbe active high synchronous.\n\nmodule TopModule (\n  input clk,\n  input reset,\n  output shift_ena\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n", "output": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput shift_ena);\n\n\tparameter B0=0, B1=1, B2=2, B3=3, Done=4;\n\t\n\treg [2:0] state, next;\n\t\n\talways_comb begin\n\t\tcase (state)\n\t\t\tB0: next = B1;\n\t\t\tB1: next = B2;\n\t\t\tB2: next = B3;\n\t\t\tB3: next = Done;\n\t\t\tDone: next = Done;\n\t\tendcase\n\tend\n\t\n\talways @(posedge clk)\n\t\tif (reset) state <= B0;\n\t\telse state <= next;\n\t\t\n\tassign shift_ena = (state == B0 || state == B1 || state == B2 || state == B3);\n\t\n\t\nendmodule\n"}
{"input": "\nBuild a four-bit shift register that also acts as a down counter. Data is\nshifted in most-significant-bit first when shift_ena is 1. The number\ncurrently in the shift register is decremented when count_ena is 1. Since\nthe full system doesn't ever use shift_ena and count_ena together, it\ndoes not matter what your circuit does if both control inputs are 1 (This\nmainly means that it doesn't matter which case gets higher priority).\n\nmodule TopModule (\n  input clk,\n  input shift_ena,\n  input count_ena,\n  input data,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput shift_ena,\n\tinput count_ena,\n\tinput data,\n\toutput reg [3:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (shift_ena)\n\t\t\tq <= { q[2:0], data };\n\t\telse if (count_ena)\n\t\t\tq <= q - 1'b1;\n\tend \n\t\nendmodule\n"}
{"input": "\nSuppose you are designing a circuit to control a cellphone's ringer and\nvibration motor. Whenever the phone needs to ring from an incoming call\n(input ring), your circuit must either turn on the ringer (output ringer\n= 1) or the motor (output motor = 1), but not both. If the phone is in\nvibrate mode (input vibrate_mode = 1), turn on the motor. Otherwise, turn\non the ringer.\n\nmodule TopModule (\n  input ring,\n  input vibrate_mode,\n  output ringer,\n  output motor\n);\n\n", "spec": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n", "output": "module top_module(\n\tinput ring, \n\tinput vibrate_mode,\n\toutput ringer,\n\toutput motor\n);\n\t\n\tassign ringer = ring & ~vibrate_mode;\n\tassign motor = ring & vibrate_mode;\n\t\nendmodule\n"}
{"input": "\nBuild a 100-bit left/right rotator, with synchronous load and left/right\nenable. A rotator shifts-in the shifted-out bit from the other end of the\nregister, unlike a shifter that discards the shifted-out bit and shifts\nin a zero. If enabled, a rotator rotates the bits around and does not\nmodify/discard them.\n\n  (1) load: Loads shift register with data[99:0] instead of rotating.\n      Synchronous active high.\n\n  (2) ena[1:0]: Synchronous. Chooses whether and which direction to\n      rotate:\n      (a) 2'b01 rotates right by one bit,\n      (b) 2'b10 rotates left by one bit,\n      (c) 2'b00 and 2'b11 do not rotate.\n\n  (3) q: The contents of the rotator.\n\nmodule TopModule (\n  input clk,\n  input load,\n  input [1:0] ena,\n  input [99:0] data,\n  output reg [99:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\t\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena == 2'h1)\n\t\t\tq <= {q[0], q[99:1]};\n\t\telse if (ena == 2'h2)\n\t\t\tq <= {q[98:0], q[99]};\n\tend\nendmodule\n"}
{"input": "\nRule 110 is a one-dimensional cellular automaton with interesting\nproperties (such as being Turing-complete). There is a one-dimensional\narray of cells (on or off). At each time step, the state of each cell\nchanges. In Rule 110, the next state of each cell depends only on itself\nand its two neighbours, according to the following table:\n\n  Left[i+1] | Center[i] | Right[i-1] | Center's next state \n  1         | 1         | 1          | 0\n  1         | 1         | 0          | 1\n  1         | 0         | 1          | 1\n  1         | 0         | 0          | 0\n  0         | 1         | 1          | 1\n  0         | 1         | 0          | 1\n  0         | 0         | 1          | 1\n  0         | 0         | 0          | 0\n\nIn this circuit, create a 512-cell system (q[511:0]), and advance by one\ntime step each clock cycle. The synchronous active high load input\nindicates the state of the system should be loaded with data[511:0].\nAssume the boundaries (q[-1] and q[512], if they existed) are both zero (off).\n\nmodule TopModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tq <= \n\t\t\t~((q[$bits(q)-1:1] & q[$bits(q)-1:0] & {q[$bits(q)-2:0], 1'b0}) |\n\t\t\t(~q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) |  \n\t\t\t(q[$bits(q)-1:1] & ~q[$bits(q)-1:0] & ~{q[$bits(q)-2:0], 1'b0}) )\n\t\t\t;\n\t\tend\n\tend\nendmodule\n"}
{"input": "\nRule 90 is a one-dimensional cellular automaton with interesting\nproperties. The rules are simple. There is a one-dimensional array of\ncells (on or off). At each time step, the next state of each cell is the\nXOR of the cell's two current neighbours:\n\n  Left | Center | Right | Center's next state\n  1    | 1      | 1     | 0\n  1    | 1      | 0     | 1\n  1    | 0      | 1     | 0\n  1    | 0      | 0     | 1\n  0    | 1      | 1     | 1\n  0    | 1      | 0     | 0\n  0    | 0      | 1     | 1\n  0    | 0      | 0     | 0\n\nIn this circuit, create a 512-cell system (q[511:0]), and advance by one\ntime step each clock cycle. The load input indicates the state of the\nsystem should be loaded with data[511:0]. Assume the boundaries (q[-1]\nand q[512]) are both zero (off).\n\nmodule TopModule (\n  input clk,\n  input load,\n  input [511:0] data,\n  output reg [511:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [511:0] data,\n\toutput reg [511:0] q);\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse begin\n\t\t\tq <= q[$bits(q)-1:1] ^ {q[$bits(q)-2:0], 1'b0} ;\n\t\tend\n\tend\nendmodule\n"}
{"input": "\nBuild a 64-bit arithmetic shift register, with synchronous load. The\nshifter can shift both left and right, and by 1 or 8 bit positions,\nselected by \"amount.\" Assume the right shit is an arithmetic right shift.\n\nSignals are defined as below:\n\n  (1) load: Loads shift register with data[63:0] instead of shifting.\n       Active high.\n  (2) ena: Chooses whether to shift. Active high.\n  (3) amount: Chooses which direction and how much to shift.\n      (a) 2'b00: shift left by 1 bit.\n      (b) 2'b01: shift left by 8 bits.\n      (c) 2'b10: shift right by 1 bit.\n      (d) 2'b11: shift right by 8 bits.\n  (4) q: The contents of the shifter.\n\nmodule TopModule (\n  input clk,\n  input load,\n  input ena,\n  input [1:0] amount,\n  input [63:0] data,\n  output reg [63:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput ena,\n\tinput [1:0] amount,\n\tinput [63:0] data,\n\toutput reg [63:0] q);\n\t\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena) case (amount)\n\t\t\t2'b00: q <= {q[62:0], 1'b0};\n\t\t\t2'b01: q <= {q[55:0], 8'b0};\n\t\t\t2'b10: q <= {q[63], q[63:1]};\n\t\t\t2'b11: q <= {{8{q[63]}}, q[63:8]};\n\t\t\tdefault: q <= 64'hx;\n\t\tendcase\n\tend\nendmodule\n"}
{"input": "\nBuild a 4-bit shift register (right shift), with asynchronous positive\nedge triggered areset, synchronous active high signals load, and enable.\n\n  (1) areset: Resets shift register to zero.\n\n  (2) load: Loads shift register with data[3:0] instead of shifting.\n\n  (3) ena: Shift right (q[3] becomes zero, q[0] is shifted out and\n       disappears).\n\n  (4) q: The contents of the shift register. If both the load and ena\n       inputs are asserted (1), the load input has higher priority.\n\nmodule TopModule (\n  input clk,\n  input areset,\n  input load,\n  input ena,\n  input [3:0] data,\n  output reg [3:0] q\n);\n\n", "spec": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n", "output": "module top_module(\n\tinput clk,\n\tinput areset,\n\tinput load,\n\tinput ena,\n\tinput [3:0] data,\n\toutput reg [3:0] q);\n\t\n\t\n\talways @(posedge clk, posedge areset) begin\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse if (load)\n\t\t\tq <= data;\n\t\telse if (ena)\n\t\t\tq <= q[3:1];\n\tend\nendmodule\n"}
{"input": "\nBuild a circuit with no inputs and one output. That output should always\ndrive 1 (or logic high).\n\nmodule TopModule (\n  output one\n);\n\n", "spec": "module top_module(\n\toutput one);\n", "output": "module top_module(\n\toutput one);\n\t\n\tassign one = 1'b1;\n\t\nendmodule\n"}
{"input": "\nA heating/cooling thermostat controls both a heater (during winter) and\nan air conditioner (during summer). Implement a circuit that will turn on\nand off the heater, air conditioning, and blower fan as appropriate. The\nthermostat can be in one of two modes: heating (mode = 1) and cooling\n(mode = 0). In heating mode, turn the heater on when it is too cold\n(too_cold = 1) but do not use the air conditioner. In cooling mode, turn\nthe air conditioner on when it is too hot (too_hot = 1), but do not turn\non the heater. When the heater or air conditioner are on, also turn on\nthe fan to circulate the air. In addition, the user can also request the\nfan to turn on (fan_on = 1), even if the heater and air conditioner are\noff.\n\nmodule TopModule (\n  input mode,\n  input too_cold,\n  input too_hot,\n  input fan_on,\n  output heater,\n  output aircon,\n  output fan\n);\n\n", "spec": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n", "output": "module top_module(\n\tinput mode,\n\tinput too_cold, \n\tinput too_hot,\n\tinput fan_on,\n\toutput heater,\n\toutput aircon,\n\toutput fan\n);\n\t\n\tassign fan = (mode ? too_cold : too_hot) | fan_on;\n\tassign heater = (mode & too_cold);\n\tassign aircon = (~mode & too_hot);\n\t\nendmodule\n"}
{"input": "\nImplement a timer that counts down for a given number of clock cycles,\nthen asserts a signal to indicate that the given duration has elapsed. A\ngood way to implement this is with a down-counter that asserts an output\nsignal when the count becomes 0. At each clock cycle:\n\n  (1) If load = 1, load the internal counter with the 10-bit data, the\n  number of clock cycles the timer should count before timing out. The\n  counter can be loaded at any time, including when it is still counting\n  and has not yet reached 0.\n\n  (2) If load = 0, the internal counter should decrement by 1. The output\n  signal tc (\"terminal count\") indicates whether the internal counter has\n  reached 0. Once the internal counter has reached 0, it should stay 0\n  (stop counting) until the counter is loaded again.\n\nmodule TopModule (\n  input clk,\n  input load,\n  input [9:0] data,\n  output tc\n);\n\n", "spec": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n", "output": "module top_module(\n\tinput clk, \n\tinput load, \n\tinput [9:0] data, \n\toutput tc\n);\n\tlogic [9:0] count_value;\n\n\talways @(posedge clk)\n\t\tif(load) count_value <= data;\n\t\telse if(count_value != 0) count_value <= count_value - 1;\n\n\tassign tc = count_value == 0;\n\nendmodule\n"}
{"input": "\nCreate a combinational circuit that implements the truth table.\n\n  x3 | x2 | x1 | f\n  0  | 0  | 0  | 0\n  0  | 0  | 1  | 0\n  0  | 1  | 0  | 1\n  0  | 1  | 1  | 1\n  1  | 0  | 0  | 0\n  1  | 0  | 1  | 1\n  1  | 1  | 0  | 0\n  1  | 1  | 1  | 1\n\nmodule TopModule (\n  input x3,\n  input x2,\n  input x1,\n  output f\n);\n\n", "spec": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n", "output": "module top_module (\n\tinput x3,\n\tinput x2,\n\tinput x1,\n\toutput f\n);\n\t\n\tassign f = ( ~x3 & x2 & ~x1 ) | \n\t\t\t\t( ~x3 & x2 & x1 ) |\n\t\t\t\t( x3 & ~x2 & x1 ) |\n\t\t\t\t( x3 & x2 & x1 ) ;\n\t\nendmodule\n"}
{"input": "\nBuild a circuit that has one 3-bit input, then outputs the same vector,\nand also splits it into three separate 1-bit outputs. Connect output o0\nto the input vector's position 0, o1 to position 1, etc.\n\nmodule TopModule (\n  input [2:0] vec,\n  output [2:0] outv,\n  output o2,\n  output o1,\n  output o0\n);\n\n", "spec": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n", "output": "module top_module(\n\tinput [2:0] vec, \n\toutput [2:0] outv,\n\toutput o2,\n\toutput o1,\n\toutput o0\n);\n\t\n\tassign outv = vec;\n\tassign {o2, o1, o0} = vec;\n\t\nendmodule\n"}
{"input": "\nBuild a combinational circuit that splits an input half-word (16 bits,\n[15:0] ) into lower [7:0] and upper [15:8] bytes.\n\nmodule TopModule (\n  input [15:0] in,\n  output [7:0] out_hi,\n  output [7:0] out_lo\n);\n\n", "spec": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n", "output": "module top_module (\n\tinput [15:0] in,\n\toutput [7:0] out_hi,\n\toutput [7:0] out_lo\n);\n\t\n\tassign {out_hi, out_lo} = in;\n\t\nendmodule\n"}
{"input": "\nGiven a 100-bit input vector [99:0], reverse its bit ordering.\n\na\n\nmodule TopModule (\n  input [99:0] in,\n  output reg [99:0] out\n);\n\n", "spec": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n", "output": "module top_module (\n\tinput [99:0] in,\n\toutput reg [99:0] out\n);\n\t\n\talways_comb \n\t\tfor (int i=0;i<$bits(out);i++)\n\t\t\tout[i] = in[$bits(out)-i-1];\n\t\nendmodule\n"}
{"input": "\nBuild a circuit that reverses the byte order of a 32-bit vector.\n\nmodule TopModule (\n  input [31:0] in,\n  output [31:0] out\n);\n\n", "spec": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n", "output": "module top_module (\n\tinput [31:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = {in[7:0], in[15:8], in[23:16], in[31:24]};\t\n\t\nendmodule\n"}
{"input": "\nGiven several input vectors, concatenate them together then split them up\ninto several output vectors. There are six 5-bit input vectors: a, b, c,\nd, e, and f, for a total of 30 bits of input. There are four 8-bit output\nvectors: w, x, y, and z, for 32 bits of output. The output should be a\nconcatenation of the input vectors followed by two 1 bits (the two 1 bits\nshould be in the LSB positions).\n\nmodule TopModule (\n  input [4:0] a,\n  input [4:0] b,\n  input [4:0] c,\n  input [4:0] d,\n  input [4:0] e,\n  input [4:0] f,\n  output [7:0] w,\n  output [7:0] x,\n  output [7:0] y,\n  output [7:0] z\n);\n\n", "spec": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n", "output": "module top_module (\n\tinput [4:0] a,\n\tinput [4:0] b,\n\tinput [4:0] c,\n\tinput [4:0] d,\n\tinput [4:0] e,\n\tinput [4:0] f,\n\toutput [7:0] w,\n\toutput [7:0] x,\n\toutput [7:0] y,\n\toutput [7:0] z\n);\n\n\tassign { w,x,y,z} = {a,b,c,d,e,f,2'b11};\n\t\nendmodule\n"}
{"input": "\nOne common place to see a replication operator is when sign-extending a\nsmaller number to a larger one, while preserving its signed value. This\nis done by replicating the sign bit (the most significant bit) of the\nsmaller number to the left. For example, sign-extending 4'b0101 (5) to 8\nbits results in 8'b00000101 (5), while sign-extending 4'b1101 (-3) to 8\nbits results in 8'b11111101 (-3). Build a circuit that sign-extends an\n8-bit number to 32 bits. This requires a concatenation of 24 copies of\nthe sign bit (i.e., replicate bit[7] 24 times) followed by the 8-bit\nnumber itself.\n\nmodule TopModule (\n  input [7:0] in,\n  output [31:0] out\n);\n\n", "spec": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n", "output": "module top_module (\n\tinput [7:0] in,\n\toutput [31:0] out\n);\n\n\tassign out = { {24{in[7]}}, in };\n\t\nendmodule\n"}
{"input": "\nGiven five 1-bit signals (a, b, c, d, and e), compute all 25 pairwise\none- bit comparisons in the 25-bit output vector. The output should be 1\nif the two bits being compared are equal. Example: out[24] = ~a ^ a;\nout[23] = ~a ^ b; out[22] = ~a ^ c; ... out[ 1] = ~e ^ d; out[ 0] = ~e ^\ne.\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  input e,\n  output [24:0] out\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\tinput e,\n\toutput [24:0] out\n);\n\n\tassign out = ~{ {5{a}}, {5{b}}, {5{c}}, {5{d}}, {5{e}} } ^ {5{a,b,c,d,e}};\n\t\nendmodule\n"}
{"input": "\nBuild a circuit that has two 3-bit inputs that computes the bitwise-OR of\nthe two vectors, the logical-OR of the two vectors, and the inverse (NOT)\nof both vectors. Place the inverse of b in the upper half of out_not\n(i.e., bits [5:3]), and the inverse of a in the lower half.\n\nmodule TopModule (\n  input [2:0] a,\n  input [2:0] b,\n  output [2:0] out_or_bitwise,\n  output out_or_logical,\n  output [5:0] out_not\n);\n\n", "spec": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n", "output": "module top_module(\n\tinput [2:0] a, \n\tinput [2:0] b, \n\toutput [2:0] out_or_bitwise,\n\toutput out_or_logical,\n\toutput [5:0] out_not\n);\n\t\n\tassign out_or_bitwise = a | b;\n\tassign out_or_logical = a || b;\n\tassign out_not = {~b,~a};\n\t\nendmodule\n"}
{"input": "\nGiven an 8-bit input vector [7:0], reverse its bit ordering.\n\nmodule TopModule (\n  input [7:0] in,\n  output [7:0] out\n);\n\n", "spec": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n", "output": "module top_module (\n\tinput [7:0] in,\n\toutput [7:0] out\n);\n\t\n\tassign {out[0],out[1],out[2],out[3],out[4],out[5],out[6],out[7]} = in;\n\t\nendmodule\n"}
{"input": "\nCreate a module with one input and one output that behaves like a wire.\n\nmodule TopModule (\n  input in,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput in,\n\toutput out);\n", "output": "module top_module(\n\tinput in,\n\toutput out);\n\t\n\tassign out = in;\n\t\nendmodule\n"}
{"input": "\nCreate a module with 3 inputs and 4 outputs that behaves like wires that\nmakes these connections:\n\n  a -> w\n  b -> x\n  b -> y\n  c -> z\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  output w,\n  output x,\n  output y,\n  output z\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\toutput w,\n\toutput x,\n\toutput y,\n\toutput z  );\n\t\n\tassign {w,x,y,z} = {a,b,b,c};\n\t\nendmodule\n"}
{"input": "\nImplement the following circuit. Create two intermediate wires (named\nanything you want) to connect the AND and OR gates together. Note that\nthe wire that feeds the NOT gate is really wire `out`, so you do not\nnecessarily need to declare a third wire here. Notice how wires are\ndriven by exactly one source (output of a gate), but can feed multiple\ninputs.\n\nThe circuit is composed of two layers. The first layer, counting from the\ninput, is two AND gates: one whose input is connected to a and b, and the\nsecond is connected to c and d. The second layer there is an OR gate to\nOR the two AND outputs, connected the output 'out'. Additionally, there\nis an inverted output 'out_n'.\n\nmodule TopModule (\n  input a,\n  input b,\n  input c,\n  input d,\n  output out,\n  output out_n\n);\n\n", "spec": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n", "output": "module top_module (\n\tinput a,\n\tinput b,\n\tinput c,\n\tinput d,\n\toutput out,\n\toutput out_n );\n\t\n\twire w1, w2;\n\tassign w1 = a&b;\n\tassign w2 = c&d;\n\tassign out = w1|w2;\n\tassign out_n = ~out;\n\t\nendmodule\n"}
{"input": "\nCreate a module that implements an XNOR gate.\n\nmodule TopModule (\n  input a,\n  input b,\n  output out\n);\n\n", "spec": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n", "output": "module top_module(\n\tinput a, \n\tinput b,\n\toutput out\n);\n\t\n\tassign out = ~(a^b);\n\t\nendmodule\n"}
{"input": "\nBuild a circuit that always outputs a LOW.\n\nmodule TopModule (\n  output zero\n);\n\n", "spec": "module top_module(\n\toutput zero);\n", "output": "module top_module(\n\toutput zero);\n\t\n\tassign zero = 1'b0;\n\t\nendmodule\n"}
